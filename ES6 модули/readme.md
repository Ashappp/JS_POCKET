![pic](http://i.piccy.info/i9/5452d984fec574fccc9aa03833ea61f2/1547201060/48889/1294309/the_many_ways_to_build_modular_javascript_45_638.jpg)

## Модули JavaScript
- [Форматы модулей](#Форматы_модулей)
   - [CommonJS](#CommonJS)
   - [AMD](#AMD)
   - [ES6](#ES6)   
- [Тонкости](#Тонкости)
- [Загрузчики модулей](#Загрузчики_модулей)
- [Сборщики модулей](#Сборщики_модулей)
- [Определения](#Определения)

------------

- [Дополнительная информация](#Дополнительная_информация)

------------



Модуль - это **функционально единая часть кода, выделенная в отдельный файл**, который может подключаться и **использоваться** в разных проектах и в **других модулях**.


Шаблон «Модуль» основывается на немедленно вызываемой функции (**IIFE**):
 ```javascript

const MODULE = (function() {
    let privateVariable = 1;

    function privateMethod() {
        // ...
    } 
    return {
        moduleProperty: 1,
        moduleMethod: function() {
            // ...
        }
    };
}());
```
Немедленно вызываемая функция **образует локальную область видимости**, в которой **можно объявить необходимые приватные свойства и методы**. 

**Результат** функции — **объект**, содержащий публичные свойства и методы.

**С помощью передачи параметров в немедленно вызываемую функцию можно импортировать зависимости в модуль**. 
Это увеличивает скорость разрешения переменных, поскольку импортированные значения становятся локальными переменными внутри функции.



## Форматы_модулей 

### CommonJS 

С точки зрения структуры **модуль CommonJS** — **это часть JavaScript-кода**, которая **экспортирует определенные переменные, объекты или функции, делая их доступными** для любого зависимого кода.

**Pеализация** этого стандарта находится **в Node.js** 
Они имеют компактный синтаксис, **предназначены для синхронной загрузки**, в основном используются на сервере.

Модуль CommonJS по существу является многократно используемым фрагментом JavaScript, который экспортирует определенные объекты, делая их доступными для других модулей, требуемых в своих программах.

С CommonJS каждый файл JavaScript хранит модули в своем собственном уникальном контексте модуля (так же, как обертывание его в замыкание). 
В этой области мы используем объект module.exports для отображения модулей и требуем их импорта.

Мы используем специальный объектный модуль и помещаем ссылку на нашу функцию в module.exports. Это позволяет системе модуля CommonJS знать, что мы хотим разоблачить, чтобы другие файлы могли ее использовать.
 
Модули CommonJS состоят из двух частей:

- **module.exports** содержит объекты, которые модуль хочет сделать доступными

- **require()** функция которая используется для импорта других модулей.

```javascript
// В файле greeter.js
function Greeter() {
  this.hello = () => "hello!"; 
  this.goodbye = () => "goodbye!";
} 
module.exports = Greeter; // экспортируем  

// В файле index.js
const Greeter = require("greeter"); // импортируем

const greeterInstance = new Greeter();
greeterInstance.hello(); // 'hello!'
greeterInstance.goodbye(); // 'goodbye!'
```

**CommonJS** использует серверный подход и **синхронно загружает модули**. Это важно, потому что, если у нас есть три других модуля, которые нам потребуются, он будет загружать их один за другим.

Это отлично работает на сервере, но, к сожалению, затрудняет использование при написании JavaScript для браузера. Чтение модуля c удаленного сервера занимает намного больше времени, чем чтение с диска. До тех пор, пока скрипт для загрузки модуля работает, он блокирует запуск браузером чем-либо еще, пока он не завершит загрузку.


### AMD

В основе формата **AMD** (Asynchronous Module Definition) лежат две функции:

- **define()** для определения именованных или безымянных модулей 

- ** require()** для импорта зависимостей.

#### Функция define() имеет следующую сигнатуру:

```JavaScript
define(
    module_id /*необязательный*/,
    [dependencies] /*необязательный*/,
    definition function /*функция для создания экземпляра модуля или объекта*/
);
```

- параметр** module_id** необязательный, он обычно требуется только при использовании не-AMD инструментов объединения. Когда этот аргумент опущен, модуль называется анонимным. 

- параметр **dependencies** представляет собой массив зависимостей, которые требуются определяемому модулю 

- третий аргумент **(definition function)** — это функция, которая выполняется для создания экземпляра модуля.

```JavaScript 
define('myModule',
    ['foo', 'bar'],
    // зависимости (foo и bar) передаются в функцию
    function(foo, bar) {
        // создаем модуль
        var myModule = {
            doStuff: function() {
                console.log('Hi!');
            }
        }
 
        // возвращаем модуль
        return myModule;
    }
);
```
#### Функция require() используется для импорта модулей:

```JavaScript 

require(['foo', 'bar'], function(foo, bar) {
    foo.doSomething();
});
```

#### Также с помощью require() можно динамически импортировать зависимости в модуль:

```JavaScript
define(function(require) {
   var foobar;
 
   require(['foo', 'bar'], function (foo, bar) {
       foobar = foo() + bar();
   });
 
   // возвращаем модуль
   // обратите внимание на другой шаблон определения модуля
   return {
       foobar: foobar
   };
});
```

### ES6

В стандарте ECMAScript 2015 появились **нативные модули JavaScript**

В основе **ES6** модулей лежат ключевые слова **export** и **import**. 
Любая переменная, объявленная в модуле, доступна за его пределами, только если явно экспортирована из модуля. 
#### ЭКСПОРТ

- **default export **  экспорт по умолчанию
Если модуль экспортирует только **ОДНО** значение, можно использовать экспорт по умолчанию. 

```javascript
// модуль экспортирует функцию:
export default function () { ··· }

// модуль экспортирует класс
export default class { ··· }

//модуль экспортирует выражение
export default 5 * 7;
```


- **named export**   именованый экспорт
модуль может экспортировать **НЕСКОЛЬКО** значений:

```javascript
// можно перед каждой сущностью которую експортируем ставить export
export const pi = Math.PI;
export function sum(x, y) => x + y;
export function multiply(x, y) => x * y; 

//Можно перечислить все, что вы хотите экспортировать, в конце модуля:
export {pi, sum, multiply};
```

- можно при экспорте **ПЕРЕИМЕНОВЫВАТЬ** значения

```javascript
// переименуем, если необходимо экспортируемые значения
export {pi as PI, sum as accum, multiply as mult};
```

#### ИМПОРТ

Импортировать модули также можно несколькими способами: 

- импорт **ОДНОГО** значения

```javascript
// Импорт значения по умолчанию
import localName from 'utils';
```

- импорт **НЕСКОЛЬКИХ** значений
```javascript 
// Импорт отдельных функций
import { sum, multiply } from 'utils';
sum(4, 3);
```

- импорт **ВСЕГО** модуля **в виде объекта** и ссылаться на него + имя **свойства**
```javascript 
// Импорт всего модуля
import * as utils from 'utils';
utils.sum(4, 3);
```

- импорт с **ПЕРЕИМЕНОВАНИЕМ**
```javascript 
// Можно переименовать импортируемое значение
import { pi as PI, sum } from 'utils';
```
- не импортировать **НИЧЕГО**
```javascript 
// Или не импортировать ничего
// (в этом случае выполнится код инициализации модуля,
// но ничего не будет импортировано)
import 'utils';
```


### Тонкости

##### Ключевые слова import и export могут использоваться только на верхнем уровне

##### Их нельзя использовать в функции или в блоке:

##### Модули ES6 выполняются отложено, только когда документ полностью проанализирован.


------------
  
### Загрузчики_модулей

**AMD** и **CommonJS** — это **форматы** модулей, а не реализации.

- Для поддержки **AMD** — необходима реализация функций **define() и require()**

- Для поддержки **CommonJS** — необходима реализация **module.exports и require()**

**Для поддержки модулей** во время выполнения **используются загрузчики** модулей. 
Существует несколько различных загрузчиков, они имеют похожий принцип работы:

1. Вы подключаете скрипт загрузчика в браузере и сообщаете ему, какой файл загрузить в качестве основного.
2. Загрузчик модулей загружает основной файл приложения.
3. Загрузчик модулей загружает остальные файлы по мере необходимости.

##### Популярные загрузчики модулей:

- **RequireJS** загружает модули в формате AMD.
- **curl.js** загружает модули AMD и CommonJS.
- **SystemJS** загружает модули AMD и CommonJS.


### Сборщики_модулей

В отличие от загрузчиков модулей, которые работают в браузере и загружают зависимости «на лету», сборщики модулей позволяют заранее подготовить один файл со всеми зависимостями (бандл).

Существует ряд инструментов, позволяющих заранее собирать модули в один файл: 

- **Browserify** поддерживает формат CommonJS.
- **Webpack** поддерживает AMD, CommonJS и ES6 модули.
- **Rollup** поддерживает ES6 модули.


### Определения 

**Модуль** — это многократно используемая часть кода, инкапсулирующая детали реализации и предоставляющая открытый API.

**Формат модуля** — это синтаксис определения и подключения модуля.

**Загрузчик модулей** —загружает модуль определенного формата во время выполнения непосредственно в браузере. Популярные загрузчики — RequireJS и SystemJS.

**Сборщик модулей** — заранее объединяет модули в один файл, который подключается на странице. Примеры сборщиков — Webpack и Browserify.

------------
 
### Дополнительная_информация

[frontender magazine](https://frontender.info/es6-modules/)

[getinstance](https://getinstance.info/articles/javascript/javascript-modules/)

[youtube](https://www.youtube.com/watch?v=CTEw9HE_IXY)

[youtube](https://www.youtube.com/watch?v=SH-OwSghB94)