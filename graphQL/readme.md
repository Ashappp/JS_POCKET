### graphQL features
- язык для взaимодейтсвия с сервером для получения данных 
- используется как посредник между клиентом и сервером,
- предоставляя единый API - One entry point
- один GraphQL запрос может возвращать связанные данные

![pic](http://i.piccy.info/i9/35b67ed340f731ffa3ab72d03b5fe781/1559328902/201483/1314369/qraphql.png)


1. [ТИПЫ](#Tипы._Type)

2. [**ЗАПРОС**](#Запрос_Query)
   2.1 [Фрагменты](#Запрос._Фрагменты)
   2.2 [Объединения](#Запрос._Объединения)
   2.3 [Интерфейсы](#Запрос._Интерфейсы.)

3. [**МУТАЦИИ**](#Мутации_Mutation)

4. [ПЕРЕМЕННЫЕ](#Переменные)

5. [**ПОДПИСКИ**](#Подписки_subscription)

6. [САМОДИАГНОСТИКА](#Самодиагностика)

7. [АБСТРАКТНЫЕ СИНТАКСИЧЕСКИЕ ДЕРЕВЬЯ](#Абстрактные_синтаксические_деревья)

8. [**СХЕМА**](#Схема)
   8.1  [Типы](#Схема._Типы.)
   8.2  [Перечисления. enum](#Типы._Перечисления)
   8.3 [Списки](#Типы._Списки)
   8.4 [Объединения. union](#Типы._Объединения)
   8.5 [Интерфейсы](#Типы._Интерфейсы) 
   8.6 [Аргументы](#Аргументы)
     8.6.1 [Фильтрация данных](#Аргументы._Фильтрация_данных)
     8.6.2 [Пагинация данных](#Аргументы._Пагинация_данных)
     8.6.3 [Сортировка](#Аргументы._Сортировка)
   8.7 [Мутации](#Схема._Мутации) 
   8.8 [Типы ввода. Input.](#Схема.Типы_ввода)
   8.9 [Возвращаемые типы.](#Схема.Возвращаемые_типы)
   8.10 [Подписки](#Схема.Подписки_Subscription)
   8.11 [Документирование схемы](#Схема._Документация)


[ДОКУМЕНТАЦИЯ GRAPHQL](https://graphql.org/)

Браузерные IDE
- GraphiQL - брузерный UI 
- [GraphQL Playground](https://www.graphqlbin.com/v2/new)

### Tипы._Type

- скалярными типами,
- типами объектов.

**Скалярные** типы похожи на примитивы в других языках.
Это листья наших выборок. В GraphQL имеется пять встроенных скалярных типов:

1. целочисленные (Int),
2. с плавающей запятой (Float),
3. строки (String), логические (Boolean)
4. уникальные идентификаторы (ID)

**Типы объектов** GraphQL представляют собой группы из одного или нескольких полей, которые вы определяете в своей схеме.
Они устанавливают форму объекта JSON, который должен быть возвращен

# Запрос_Query

Запрос описывает данные, которые вы хотите получить от сервера GraphQL

Когда вы отправляете запрос, вы запрашиваете единицы данных по полям.

Эти поля отображаются в том же поле в ответе данных в формате JSON, который вы получаете с сервера

Например, если вы отправляете запрос allLifts и запрашиваете поля name и status, вы должны получить ответ в формате JSON, содержащий массив allLifts и строки name и status каждого подъемника, как показано здесь:

```js
query {
  allLifts {
  name
  status
 }
}
```

- Вы можете добавить несколько запросов к документу запроса, но одновременно можно инициировать **только одну операцию**.

Если требуется отправить один запрос всех указанных данных, то нужно поместить все в один и тот же запрос:

```js
query liftsAndTrails {
  liftCount(status: OPEN)
    allLifts {
      name
      status
    }
    allTrails {
      name
      difficulty
    }
}
```

`query` — **это тип GraphQL**.
Мы называем его корневым типом, потому что это тип, который сопоставляется с операцией, а операции представляют собой корни нашего документа запроса.
Поля, доступные для запроса в API GraphQL, определены в данной схеме API.
В документации указывается, какие поля доступны для выбора в типе query.

Когда мы пишем запросы, мы выбираем поля, которые нам нужны, **заключая их в фигурные скобки**.
Эти блоки называются **выборками**.
Поля, которые мы определяем в выборке, напрямую связаны с типами GraphQL.

Ответ в формате JSON содержит все данные, которые мы запросили.

Эти данные форматируются как JSON и поставляются в том же виде, что и наш запрос.

Каждому полю JSON выдается то же имя, что и поле в нашей выборке.

- Мы можем изменить имена полей в объекте ответа в запросе, указав псевдонимы, как показано ниже:

```js
query liftsAndTrails {
  open: liftCount(status: OPEN) // псевдоним open
    chairlifts: allLifts {      // псевдоним chairlifts
    liftName: name              // псевдоним liftName
    status
  }
  skiSlopes: allTrails {        // псевдоним skiSlopes
    name
    difficulty
  }
}
```

Ниже приводится ответ:

```js
{
 "data": {
 "open": 5,
 "chairlifts": [
  {
  "liftName": "Astra Express",
  "status": "open"
  }
  ],
  "skiSlopes": [
  {
  "name": "Ditch of Doom",
  "difficulty": "intermediate"
  }
 ]
 }
}
```

#### Запрос._Фрагменты

Документ GraphQL-запроса может содержать определения операций и фрагментов. Фрагменты — **это выборки, которые можно повторно использовать** в нескольких операциях

```js
query {
  Lift(id: "jazz-cat") {
    name
    status
    capacity
    night
    elevationGain
    trailAccess {
      name
      difficulty
    }
  }
  Trail(id: "river-run") {
    name
    difficulty
    accessedByLifts {
      name
      status
      capacity
      night
      elevationGain
    }
  }
}
```

Как видно из запроса эти поля повторяются в нескольких выборках

```js
name;
status;
capacity;
night;
elevationGain;
```

Фрагменты создаются с помощью идентификатора `fragment`.

Фрагменты — это выборки определенных типов, поэтому вы должны указать тип, связанный с каждым фрагментом, в его определении.

**Фрагменты бывают**

- именованые
- встроенные

Пример с `встроенными` фрагметами `...on`

```js
query schedule {
  agenda {
    ...on Workout {    // тип Workout
      name
      reps
    }
    ...on StudyGroup { // тип StudyGroup
      name
      subject
      students
    }
  }
}
```

- Пример с `именоваными` фрагментами создаем путем объявления `fragment customName on TypeName` и затем используется в теле запроса

```js
query today {
 agenda {
 ...workout  // именованый фрагмент
 ...study    // именованый фрагмент
 }
}

// именованый фрагмент
fragment workout on Workout {
 name
 reps
}

// именованый фрагмент
fragment study on StudyGroup {
 name
 subject
 students
}
```

Фрагмент в данном примере называется `liftInfo`, и это выборка `Lift`.

```js
fragment liftInfo on Lift {
  name
  status
  capacity
  night
  elevationGain
}
```

Когда нужно добавить поля фрагмента liftInfo в другую выборку, следует указать три точки и имя фрагмента

```js
query {
  Lift(id: "jazz-cat") {
  ...liftInfo   // используем фрагмент
  trailAccess {
    name
    difficulty
    }
  }
  Trail(id: "river-run") {
    name
    difficulty
    accessedByLifts {
    ...liftInfo   // используем фрагмент
    }
  }
}
```

Фрагменты можно сочетать

```js
query {
  allTrails {
  ...trailStatus   // используем фрагмент
  ...trailDetails  // используем фрагмент
  }
}
// фрагмент
fragment trailStatus on Trail {
  name
  status
}

// фрагмент
fragment trailDetails on Trail {
  groomed
  trees
  night
}
```

### Запрос._Объединения.

Если нужно в одном запросе получать более одного типа, то можно создавать объединения, связывающие разные типы объектов

- Пример с `встроенными` фрагметами ...on

```js
query schedule {
  agenda {
    ...on Workout {    // тип Workout
      name
      reps
    }
    ...on StudyGroup { // тип StudyGroup
      name
      subject
      students
    }
  }
}
```

- Пример с `именоваными` фрагментами

```js
query today {
 agenda {
 ...workout  // именованый фрагмент
 ...study    // именованый фрагмент
 }
}

// именованый фрагмент
fragment workout on Workout {
 name
 reps
}

// именованый фрагмент
fragment study on StudyGroup {
 name
 subject
 students
}
```

Ответ прийдет с теми полями типов которые указали

### Запрос._Интерфейсы.

Интерфейсы — это еще один вариант при работе с несколькими типами объектов, которые могут быть возвращены в одном поле.
При запросе интерфейса мы также можем использовать фрагменты для выборки дополнительных полей при возврате определенного типа объекта

Интерфейс представляет собой абстрактный тип, устанавливающий список полей, которые должны быть реализованы в похожих типах объектов.

```js
query schedule {
  agenda {
    name
    start
    end
    ...on Workout {
      reps
    }
  }
}
```

# Мутации_Mutation

Mutation — корневой тип данных.
Используются для изменения существующих или добавления новых данных.
Схема API определяет поля, доступные для этого типа.

```js
// создание новой песни
mutation createSong {
  addSong(title:"No Scrubs", numberOne: true) {
  id
  title
  numberOne
  }
}

// пример ответа на данную мутацию
{
 "data": {
  "addSong": {
    "id": "5aca534f4bb1de07cb6d73ae",
    "title": "No Scrubs",
    "numberOne": true
  }
 }
}
```

Мы также можем задействовать мутации для изменения существующих данных.
Предположим, что нам нужно изменить статус канатной дороги «Снежный клык».
Мы могли бы использовать мутацию вот так:

```js
mutation closeLift {
 setLiftStatus(id: "jazz-cat" status: CLOSED) {
  name
  status
 }
}
```

### Переменные

Пишутся через `$varname : vartype` также можно добавить `!` обязательна ли переменная иили нет

Переменные заменяют статическое значение в запросе, чтобы вместо этого мы могли передавать динамические значения

Объявим переменные owner и name, которые используем в как параметры в запросе

```js
mutation createSong($title:String! $numberOne:Int $by:String!){
 addSong(title:$title, numberOne:$numberOne, performerName:$by){
  id
  title
  numberOne
 }
}
```

# Подписки_subscription

Третий тип операции, доступный с помощью GraphQL, — **это подписка**.

Бывают случаи, когда клиент может захотеть получать обновления в реальном времени с сервера.

Подписка позволяет **перехватывать события API GraphQL** для изменения данных в реальном
времени.

Подобно мутации и запросу, **подписка является корневым типом**.

Изменения данных, которые клиенты могут отслеживать, определяются в схеме API как поля под типом `subscription`.

Мы можем отслеживать изменение статуса любого подъемника с помощью подписки:

```js
subscription {
  liftStatusChange {
    name
    capacity
    status
  }
}
```

- Когда мы запускаем эту подписку, мы отслеживаем изменения статуса подъемника

- Когда подписка отправляется на сервер, она отслеживает любые изменения данных

- Чтобы увидеть результат работы подписки нужно отправить мутацию.

# Самодиагностика

Самодиагностика — это возможность запрашивать **детали о текущей схеме API**.
Например, если нужно знать, какие типы GraphQL доступны в нашем API, мы можем просмотреть эту информацию, выполнив запрос \_\_schema,

```js
query {
  __schema {
    types {
      name
      description
    }
  }
}
```

мы видим все типы, доступные в API, включая корневые, пользовательские и даже скалярные.

Если нужны данные определенного типа, мы можем, выполняя запрос \_\_type, отправить имя нужного типа в качестве аргумента:

```js
// Этот запрос на самотестирование показывает нам все поля, доступные для запроса Lift
query liftDetails {
  __type(name:"Lift") {
    name
    fields {
      name
      description
      type {
       name
      }
    }
  }
}
```

# Абстрактные_синтаксические_деревья

Документ запроса представляет собой строку.
Когда мы отправляем запрос в API GraphQL, эта строка разбирается на абстрактное синтаксическое дерево и проверяется до запуска операции.

- АСД — иерархический объект, представляющий наш запрос.
- АСД — объект, который содержит вложенные поля, представляющие детали GraphQL-запроса.

#### Flow

1. Первым шагом в данном процессе является разделение строки на меньшие части.
   Это включает в себя анализ ключевых слов, аргументов и даже скобок и двоеточий в набор отдельных токенов.
   Такой процесс называется **лексированием или лексическим анализом**.

2. Затем лексированный запрос анализируется в АСД.
   Запрос намного проще динамически модифицировать и проверять в виде АСД.
   Например, ваши запросы начинаются как документ GraphQL.

Документ содержит хотя бы одно определение, но оно также может содержать и список определений.

**Определения** могут быть только одного из двух типов:

- OperationDefinition (query, mutation, subscription)

- FragmentDefinition (fragment)

Ниже приведен пример документа, который содержит **три** определения — **две операции и один фрагмент**:

```js
query jazzCatStatus {    // OperationDefinition
  Lift(id: "jazz-cat") {  // SelectionSet
    name
    night
    elevationGain
    trailAccess {
      name
      difficulty
    }
  }
}

mutation closeLift($lift: ID!) {  // OperationDefinition
 setLiftStatus(id: $lift, status: CLOSED ) {
 ...liftStatus
 }
}

fragment liftStatus on Lift {    // FragmentDefinition
 name
 status
}
```

**OperationDefinition** может содержать только один из трех типов операций:

- mutation
- query
- subscription

Каждое **OperationDefinition** операции содержит

- OperationType (три типа корневых операций)
- SelectionSet (выборка)

**Фигурные скобки**, которые указываются после каждой операции, содержат выборку `SelectionSet`.

Это фактические поля, которые мы запрашиваем вместе с их аргументами.
Например, поле Lift — это SelectionSet для запроса jazzCatStatus, а поле setLiftStatus представляет собой выборку для мутации closeLift.

Выборки вложены друг в друга.

```js
query jazzCatStatus {     // OperationDefinition - query
  Lift(id: "jazz-cat") {  // 1 SelectionSet
    name                  // 2 SelectionSet
    night                 // 2 SelectionSet
    elevationGain         // 2 SelectionSet
    trailAccess {         // 2 SelectionSet
      name                // 3 SelectionSet
      difficulty          // 3 SelectionSet
    }
  }
}
```

Запрос jazzCatStatus содержит **три** вложенные `SelectionSet` (выборки).

1. Первая выборка SelectionSet включает поле Lift.
2. Внутрь вложена выборка SelectionSet, которая содержит поля name, night, elevationGain, trailAccess
3. Ниже поля trailAccess вложена еще одна выборка SelectionSet, которая включает поля name и difficulty

GraphQL может пройтись по этому АСД и проверить его относительно языка GraphQL и текущей схемы.

- Если синтаксис языка запроса **правильный**, а схема содержит поля и типы, которые мы запрашиваем, **выполняется операция**.

- Если нет, вместо этого **возвращается соответствующая ошибка**.

# Схема

Представления API как колекции типов - называемых схемой.

`Schema First` — это методология проектирования, при которой все ваши команды оповещаются о типах данных, составляющих ваше приложение.

Команда бэкенд-разработчиков будет иметь четкое представление о данных, которые необходимо хранить и доставлять.

У команды фронтенд-разработки будут определения, необходимые для создания пользовательских интерфейсов.

У каждого будет четкий список терминов, которые они смогут применять для общения относительно собираемой системы.

GraphQL поддерживает язык, который можно использовать для определения схем, называемый `Schema Definition Language` или `SDL`

## Схема._Типы.

Основным элементом любой схемы GraphQL является тип.

- тип это пользовательский объект
- типы представляют данные вашего приложения
- тип имеет поля, которые представляют данные, связанные с каждым объектом.
- каждое поле возвращает определенный тип данных.

Схема представляет собой набор определений типов.

Определим первый тип объекта GraphQL в нашем файле схемы — Photo:
Каждое поле содержит данные определенного типа.
Как уже известно типы могут быть `скалярными` либо `объектами`

```js
type Photo {
  id: ID!
  name: String!
  url: String!
  description: String
}
```

Восклицательный знак указывает, что данное поле не может быть нулевым `null`, а это означает, что поля name и url должны возвращать некоторые данные в каждом запросе.

также можно создавать свой скалярный тип

```js
scalar DateTime
```

В npm-пакете `graphql-custom-types` есть некоторые широко применяемые пользовательские скалярные типы, которые вы можете быстро добавить в свой сервис Node.js GraphQL.

#### Типы._Перечисления

Типы `перечислений`, или `enum`, являются скалярными типами, которые позволяют полю возвращать ограниченный набор строковых значений.

Например, создадим тип enum с именем PhotoCategory, который определяет тип фотографии одним из пяти возможных вариантов — SELFIE, PORTRAIT, ACTION, LANDSCAPE или GRAPHIC:

```js
enum PhotoCategory {
 SELFIE
 PORTRAIT
 ACTION
 LANDSCAPE
 GRAPHIC
}
```

При определении полей вы можете использовать типы перечисления.
Добавим поле category к нашему типу объекта Photo:

```js
type Photo {
  id: ID!
  name: String!
  url: String!
  description: String
  created: DateTime!
  category: PhotoCategory!  // enum
}
```

#### Типы._Списки

Когда вы создаете схемы GraphQL, вы можете определять поля, которые возвращают списки любого типа GraphQL.
Списки создаются путем окружения типа GraphQL квадратными скобками.
[String] определяет список строк, а [PhotoCategory] — список категорий фотографий

#### Типы._Объединения

В GraphQL **тип объединения** — это тип, который мы можем использовать **для возврата одного из нескольких разных типов**.

```js
 query schedule {
  agenda {          // тип объединения
    ...on Workout {
    name
    reps
    }
    ...on StudyGroup {
    name
    subject
    students
    }
  }
}
```

Альтернативная запись

AgendaItem объединяет StudyGroup и Workout в виде одного типа.

```js
union AgendaItem = StudyGroup | Workout

type StudyGroup {
 name: String!
 subject: String
 students: [User!]!
}

type Workout {
 name: String!
 reps: Int!
}

type Query {
 agenda: [AgendaItem!]!
}
```

Можно объединить столько типов, сколько нужно в рамках единого объединения

```js
union = StudyGroup | Workout | Class | Meal | Meeting | FreeTime;
```

#### Типы._Интерфейсы

Другим способом обработки полей, которые могут содержать разные типы, являются интерфейсы

- Интерфейсы представляют собой абстрактные типы, которые могут быть реализованы как типы объекта.

- Интерфейс определяет все поля, которые должны быть включены в любой объект, который его реализует.

- Интерфейсы — отличный способ организовать код в вашей схеме. Это гарантирует, что определенные типы всегда включают определенные поля, которые запрашиваются независимо от возвращаемого типа.

```js
scalar DataTime

interface AgendaItem {    // объявили тип интерфейс
  name: String!
  start: DateTime!
  end: DateTime!
}

type StudyGroup implements AgendaItem {
  name: String!
  start: DateTime!
  end: DateTime!
  participants: [User!]!
  topic: String!
}

type Workout implements AgendaItem {
  name: String!
  start: DateTime!
  end: DateTime!
  reps: Int!
}

type Query {
  agenda: [AgendaItem!]! // список
}
```

В этом примере мы создаем интерфейс AgendaItem.
Он является абстрактным типом, который могут реализовать другие типы.

Когда другой тип реализует интерфейс, он должен содержать поля, определенные интерфейсом.
Оба типа, StudyGroup и Workout, реализуют интерфейс AgendaItem, поэтому им нужно использовать поля имени, начала и конца.

В списке `agenda` запроса отображается перечень типов AgendaItem.

Любой тип, который реализует интерфейс AgendaItem, может быть возвращен в списке agenda.

Обратите внимание и на то, что эти типы также могут реализовывать другие поля.
В StudyGroup есть topic и список участников, и у отработки занятия все еще есть повторы.

Вы можете выбрать данные дополнительные поля в запросе с помощью фрагментов.

Объединения и интерфейсы — это инструменты, которые можно использовать для создания полей, содержащих разные типы объектов.

- если объекты содержат совершенно **разные** поля, **рекомендуется применять объединения**.

- если тип объекта должен содержать **определенные** поля для взаимодействия с другим типом объекта, вам **нужно будет использовать интерфейс**, а не объединение

## Аргументы

Аргументы могут быть добавлены в любое поле в GraphQL.

Они позволяют нам отправлять данные, которые могут повлиять на результаты наших операций в GraphQL.

Тип Query содержит поля, которые будут перечислять allUsers или allPhotos

Но что происходит, когда вы хотите выбрать только одного пользователя или одну фотографию?

Вам нужно будет предоставить некоторую информацию об одном пользователе или выбранной фотографии.

Вы можете отправить эту информацию вместе с запросом в качестве аргумента:

```js
type Query {
 ...
 User(githubLogin: ID!): User!
 Photo(id: ID!): Photo!
}
```

Точно так же, как поле, аргумент должен иметь тип.
Данный тип может быть определен с использованием любого из скалярных типов объектов, доступных в нашей схеме.

Чтобы выбрать конкретного пользователя, нам нужно отправить его уникальный githubLogin
в качестве аргумента.

Следующий **запрос** выбирает только имя и аватар MoonTahoe:

```js
query {
  User(githubLogin: "MoonTahoe") {
    name
    avatar
  }
}
```

Чтобы выбрать информацию об отдельной фотографии, необходимо указать ее идентификатор:

```js
query {
  Photo(id: "14TH5B6NS4KIG3H4S") {
    name
    description
    url
  }
}
```

В обоих случаях аргументы требовались для запроса сведений об одной конкретной записи.

Поскольку эти аргументы обязательны, они определяются как поля, не допускающие нулевое значение.

Если мы не предоставляем id или githubLogin в этих запросах, парсер GraphQL вернет ошибку

### Аргументы._Фильтрация_данных

Аргументы не должны быть ненулевыми.
Мы можем добавить необязательные аргументы, используя нулевые поля.

Это означает, что мы можем поставлять аргументы в качестве необязательных параметров при выполнении операций запроса.

Например, отфильтровать список фотографий, возвращаемый запросом allPhotos, по категории фотографий:

```js
type Query {
 allPhotos(category: PhotoCategory): [Photo!]!
}
```

Мы добавили необязательное поле category в запрос allPhotos.

Категория должна соответствовать значениям типа перечисления PhotoCategory.

Если значение не отправляется с запросом, можно предположить, что это поле вернет каждую фотографию.

Однако, если категория предоставлена, мы должны получить отфильтрованный список фотографий в той же категории:

```js
query {
  allPhotos(category: "SELFIE") {
    name
    description
    url
  }
}
```

Этот запрос возвращает name, description и url каждой фотографии, классифицированной как SELFIE.

### Аргументы._Пагинация_данных

Если наше приложение PhotoShare станет популярным, а оно станет, в нем будет много пользователей (Users) и фотографий (Photos).

Возврат каждого User или каждого Photo в нашем приложении может оказаться невозможным.

Мы можем применять аргументы GraphQL для управления объемом данных, возвращаемых из наших запросов.

Этот процесс называется `разбиением данных` на страницы или `пагинацией`, потому что для представления **одной страницы данных возвращается определенное количество записей**.

Чтобы реализовать пагинацию данных, мы добавим два необязательных аргумента:

- **first**, чтобы собрать количество записей, которые должны быть возвращены сразу на одной странице данных
- **start**, чтобы определить начальную позицию или индекс первой записи для возврата.

Мы можем добавить эти аргументы в оба наших списка запросов:

```js
type Query {
 allUsers(first: Int=50 start: Int=0): [User!]!
 allPhotos(first: Int=25 start: Int=0): [Photo!]!
}
```

В предыдущем примере мы добавили необязательные аргументы `first` и `start`.

Если клиент не предоставит эти аргументы в запросе, мы будем применять предоставленные **значения по умолчанию** .

По умолчанию запрос **allUsers** возвращает только первых 50 пользователей, а запрос **allPhotos** возвращает только первые 25 фотографий.

Клиент может запросить другой диапазон пользователей или фотографий, указав значения этих аргументов.

Например, если нам нужно выбрать пользователей с номерами от 90 до 100, мы могли бы сделать это, применяя следующий запрос:

```js
query {
  allUsers(first: 10 start: 90) {
    name
    avatar
  }
}
```

Данный запрос выбирает только десять записей, начиная с 90-го пользователя.

Он должен вернуть name и avatar для указанного диапазона пользователей.

Мы можем вычислить общее количество страниц, доступных на клиенте, разделив общее количество элементов на размер одной страницы данных:

```js
pages = pageSize / total;
```

### Аргументы._Сортировка

При запросе списка данных мы также можем определить способ сортировки возвращаемого списка данных.

Для этого также применяются аргументы.

Рассмотрим сценарий, в котором мы хотим включить возможность сортировки любых списков записей Photo.

Один из способов решения указанной задачи — создание перечислений, которые определяют, какие поля можно использовать для сортировки объектов Photo, и добавление инструкции для сортировки этих полей:

```js
enum SortDirection {
  ASCENDING
  DESCENDING
}

enum SortablePhotoField {
  name
  description
  category
  created
}

Query {
  allPhotos(
  sort: SortDirection = DESCENDING
  sortBy: SortablePhotoField = created
  ): [Photo!]!
}
```

Здесь мы добавили аргументы `sort` и `sortBy` в запрос **allPhotos**.

- Мы создали тип перечисления, называемый **SortDirection**, который мы можем использовать, чтобы ограничить значения аргумента sort как `ASCENDING` или `DESCENDING`.

- Мы также создали другой тип перечисления, **SortablePhotoField**.

Мы не хотим сортировать фотографии по любому полю, поэтому ограничили значения `sortBy`, чтобы включить только четыре поля фотографии: name, description, category или created (дата и время добавления фотографии).

И `sort`, и `sortBy` являются необязательными аргументами, так что по умолчанию применяются значения DESCENDING и created соответственно, если какой-либо из аргументов не указан.

Теперь клиенты могут управлять сортировкой фотографий при выдаче запроса allPhotos:

```js
query {
  allPhotos(sortBy: name)
}
```

Этот запрос вернет все фотографии, отсортированные по имени в нисходящем порядке.

До сих пор мы добавляли аргументы только к полям типа Query, **но важно отметить, что вы можете добавлять аргументы к любому полю**.

Мы могли бы добавить параметры фильтрации, сортировки и пагинации к фотографиям, которые были отправлены одним пользователем:

```js
type User {
  postedPhotos(
    first: Int = 25
    start: Int = 0
    sort: SortDirection = DESCENDING
    sortBy: SortablePhotoField = created
    category: PhotoCategory
  ): [Photo!]

```

Добавление фильтров пагинации может помочь уменьшить объем данных, которые возвращает запрос.

## Схема._Мутации

Мутации должны определяться в схеме.
Подобно запросам, они также определяются в своем собственном пользовательском типе объекта и добавляются в схему.

Технически нет никакой разницы между тем, как мутация или запрос определены в вашей схеме.

Разница в намерении. Мы должны создавать мутации только тогда, когда действие или событие что-то изменит в отношении состояния нашего приложения.

Мутации можно представить как глаголы в вашем приложении.

Они должны состоять из того, что пользователи могут делать с вашим сервисом.

При разработке сервиса GraphQL создайте список всех действий, которые пользователь может выполнить с вашим
приложением.

Скорее всего, это и будут ваши мутации.

В приложении PhotoShare пользователи могут войти в систему с помощью GitHub, опубликовать и сопроводить тегами фотографии.

Все эти действия меняют что-то в состоянии приложения.

После авторизации через аккаунт GitHub обращения текущих пользователей к клиенту будут меняться.

Когда пользователь отправляет фотографию, в системе будет добавлено дополнительное фото.

То же самое верно для добавления тегов к фотографии.

Новые записи данных тегов генерируются каждый раз при добавлении тега к фотографии.

Мы можем добавить эти мутации в корневой тип мутации в нашей схеме и сделать их доступными для клиента.

Начнем с нашей первой мутации, postPhoto:

```js
type Mutation {
  postPhoto(                // метод мутации
  name: String!
  description: String
  category: PhotoCategory=PORTRAIT
  ): Photo!
}

schema {
 query: Query
 mutation: Mutation
}
```

Добавление поля postPhoto типа Mutation позволяет пользователям публиковать фотографии.

Когда пользователь отправляет фотографию, для нее требуется как минимум name. description и category являются необязательными.

Если аргумент category не указан, опубликованная фотография будет установлена по умолчанию как PORTRAIT.

Например, пользователь может опубликовать фотографию, отправив следующую мутацию:

```js
mutation {
  postPhoto(name: "Sending the Palisades") {
    id
    url
    created
    postedBy {
     name
    }
  }
}
```

После того как пользователь отправляет фотографию, он может выбирать информацию о фотографии, которую только что опубликовал.

Это хорошо, потому что некоторые данные о новой фотографии будут сгенерированы на сервере.
В базе данных будет создан `ID` новой фотографии.
Будет автоматически сгенерирован ее `url`.
На фото также будут отмечены дата и время создания `created` фотографии.
Данный запрос выбирает все эти новые поля после публикации фотографии.
Кроме того, выборка включает информацию о пользователе `name`, который опубликовал фотографию.
Пользователь должен авторизоваться, чтобы опубликовать фотографию.
Если в настоящий момент он не авторизован, эта мутация должна возвращать ошибку.
Предполагая, что пользователь авторизован, мы можем получить информацию о том, кто опубликовал фотографию, с помощью поля postedBy.

## Схема.Типы_ввода

Как вы могли заметить, аргументы для нескольких наших запросов и мутаций становятся довольно длинными. Существует лучший способ организовать эти аргументы с **использованием типов ввода**.

**Тип ввода аналогичен типу объекта** GraphQL, за исключением того, что **применяется ТОЛЬКО ДЛЯ ВХОДНЫХ аргументов**.

Улучшим мутацию postPhoto с использованием типа ввода для наших аргументов:

```js
input PostPhotoInput {
 name: String!
 description: String
 category: PhotoCategory=PORTRAIT
}

type Mutation {
 postPhoto(input: PostPhotoInput!): Photo!
}
```

Тип **PostPhotoInput** похож на тип объекта, но он был создан только для входных аргументов.

Для этого требуются поля name и description, а поля category по-прежнему являются необязательными.
Теперь при отправке мутации postPhoto сведения о новой фотографии должны быть включены в один объект:

```js
mutation newPhoto($input: PostPhotoInput!) { // определили в переменную тип ввода
  postPhoto(input: $input) {  // использовали тип ввода
    id
    url
    created
  }
}
```

Когда мы создаем эту мутацию, мы устанавливаем тип переменной запроса `$input` для соответствия нашему типу ввода PostPhotoInput!.

Он не является нулевым, потому что как минимум нам нужно получить доступ к полю input.name, чтобы добавить
новую фотографию.

Когда мы отправляем мутацию, необходимо предоставить новые фотоданные в наших переменных запроса, вложенных в поле input:

```js
{
"input": {
  "name": "Hanging at the Arc",
  "description": "Sunny on the deck of the Arc",
  "category": "LANDSCAPE"
  }
}
```

Наш ввод сгруппирован в объект JSON и отправлен вместе с мутацией в переменных запроса в виде ключа "input".

Поскольку переменные запроса отформатированы как JSON, категория должна быть строкой, которая соответствует одной из категорий типа PhotoCategory.

Типы ввода — это ключ к организации и написанию четкой схемы GraphQL.
Вы можете добавлять типы ввода как аргументы в любом поле для улучшения пагинации данных и фильтрации данных в приложениях.

Посмотрим, как мы можем организовать и повторно использовать все поля сортировки и фильтрации с помощью типов ввода:

```js
input PhotoFilter {
  category: PhotoCategory
  createdBetween: DateRange
  taggedUsers: [ID!]
  searchText: String
}

input DateRange {
  start: DateTime!
  end: DateTime!
}
input DataPage {
  first: Int = 25
  start: Int = 0
}
input DataSort {
  sort: SortDirection = DESCENDING
  sortBy: SortablePhotoField = created
}

type User {
  postedPhotos(filter:PhotoFilter paging:DataPage
  sorting:DataSort): [Photo!]!
  inPhotos(filter:PhotoFilter paging:DataPage
  sorting:DataSort): [Photo!]!
}

type Photo {
  taggedUsers(sorting:DataSort): [User!]!
}

type Query {
  allUsers(paging:DataPage sorting:DataSort): [User!]!
  allPhotos(filter:PhotoFilter paging:DataPage
  sorting:DataSort): [Photo!]!
}
```

Мы **организовали** множество полей в виде **типов ввода** и повторно **использовали эти поля в качестве аргументов** в нашей схеме.

- Типы ввода **PhotoFilter** содержат необязательные поля ввода, которые позволяют клиенту фильтровать список фотографий.

- Тип **PhotoFilter** включает вложенный тип ввода DateRange в виде поля createdBetween.

- **DateRange** должен включать даты начала и окончания.

- Используя **PhotoFilter**, мы также можем фильтровать фотографии по категориям, строке поиска или taggedUsers.

Мы добавляем все параметры фильтра в каждое поле, которое возвращает список фотографий.
Это дает клиенту большой контроль над тем, какие фотографии возвращаются из каждого списка.

**Типы ввода также были созданы для пагинации и сортировки.**

- Тип ввода **DataPage** содержит поля, необходимые для запроса страницы данных

- тип ввода **DataSort** — наши поля сортировки.

Эти типы ввода были добавлены в каждое поле в нашей схеме, которое возвращает список данных.

Мы могли бы написать запрос, который принимает некоторые довольно сложные входные данные, используя доступные типы ввода:

```js
query getPhotos($filter:PhotoFilter $page:DataPage $sort:DataSort) {
  allPhotos(filter:$filter paging:$page sorting:$sort) {
    id
    name
    url
  }
}
```

Этот запрос не обязательно принимает аргументы для трех типов ввода: $filter, $page и \$sort.
Используя переменные запроса, мы можем отправить некоторые конкретные сведения о том, какие фотографии хотели бы выбрать:

```js
{
  "filter": {
    "category": "ACTION",
    "taggedUsers": ["MoonTahoe", "EvePorcello"],
    "createdBetween": {
      "start": "2018-11-6",
      "end": "2018-5-31"
    }
  },
  "page": {
    "first": 100
 }
}
```

В этом запросе будут найдены все фотографии в категории ACTION, на которых GitHub-пользователи MoonTahoe и EvePorcello поставили теги с 6 ноября по 31 мая, то есть во время лыжного сезона.
Кроме того, здесь мы запрашиваем первые 100 фотографий.

**Типы ввода помогают упорядочивать схемы и использовать аргументы**.

Они также улучшают документацию схемы, которую автоматически генерирует GraphiQL или GraphQL Playground. Это сделает API более доступным и более простым в освоении и оценке.
Наконец, вы можете применять типы ввода, чтобы предоставить клиенту большие возможности для выполнения организованных запросов.

## Схема.Возвращаемые_типы

Все поля в нашей схеме возвращают наши основные типы — User и Photo. 
Но иногда нам нужно возвращать метаинформацию о запросах и мутациях в дополнение к фактическим данным полезной нагрузки.  

Например, когда пользователь авторизовался и прошел аутентификацию, нам нужно вернуть токен в дополнение к полезной нагрузке для User.

Чтобы авторизоваться с помощью GitHub OAuth, мы должны получить код OAuth от GitHub.  
Предположим, что у нас есть допустимый код GitHub, который мы можем отправить мутации githubAuth для авторизации пользователя:

```js
type AuthPayload {
 user: User!
 token: String!
}

type Mutation { 
 githubAuth(code: String!): AuthPayload!
}
```

Пользователи аутентифицируются путем отправки допустимого кода GitHub в мутацию githubAuth. 

В случае успеха мы вернем тип пользовательского объекта, содержащий как информацию об успешно авторизованном пользователе, так и токен, который может применяться для авторизации дополнительных запросов и мутаций, включая мутацию postPhoto.

Можно задействовать пользовательские типы возвращаемых данных в любом поле, для которого нужны более простые данные полезной нагрузки. 

Возможно, необходимо знать, сколько времени требуется запросу для доставки ответа или сколько результатов
было найдено в конкретном ответе в дополнение к данным полезной нагрузки запроса. 

Вы можете обрабатывать все это с помощью пользовательского возвращаемого типа.
 
## Схема.Подписки_Subscription

Типы Subscription не отличаются от любого другого типа объекта на языке определения схемы GraphQL. 

Здесь мы определяем доступные подписки как поля в пользовательском типе объектов. 
 
Например, мы можем добавить подписки, которые позволят нашим клиентам быть в курсе создания новых типов Photo или User:
```js
type Subscription {
  newPhoto: Photo!
  newUser: User!
}

schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}
```
Здесь мы создаем пользовательский объект **Subscription**, который содержит два поля: newPhoto и newUser.

- Когда будет опубликовано новое фото, эта новая фотография будет передана всем клиентам, оформившим подписку newPhoto. 
- Когда будет создан новый пользователь, его данные передадутся каждому клиенту, подписанному на оповещения о новых пользователях.

Подобно запросам или мутациям, **подписки могут использовать аргументы**. 

Предположим, нам нужно добавить фильтры к подписке newPhoto, которая будет оповещать только о новых фотографиях в категории ACTION:

```js
type Subscription {
  newPhoto(category: PhotoCategory): Photo!
  newUser: User!
}
```

Когда пользователи оформляют подписку **newPhoto**, у них появляется возможность фильтровать фотографии, которые были добавлены к этой подписке. Например, чтобы фильтровать только новые фотографии в категории ACTION, клиенты могли бы отправить следующую операцию в наш API GraphQL:

```js
subscription {
  newPhoto(category: "ACTION") {
    id
    name
    url
    postedBy {
      name
    }
  }
}
```
Такая подписка должна возвращать данные только для фотографий в категории ACTION.

## Схема._Документация

При написании схемы GraphQL вы можете добавить необязательные описания для каждого поля, которые предоставят дополнительную информацию о типах и полях схемы.

Предоставление описаний может облегчить вашей команде, вам и другим пользователям API понимание вашей системы типов.

Например, добавим комментарии к типу User в нашей схеме:

```js
"""
A user who has been authorized by GitHub at least once
"""
type User {
 """
 The user's unique GitHub login
 """
 githubLogin: ID!

 """
 The user's first and last name
 """
 name: String
 """
 A url for the user's GitHub profile photo
 """
 avatar: String
 """
 All of the photos posted by this user
 """
 postedPhotos: [Photo!]!
 """
 All of the photos in which this user appears
 """
 inPhotos: [Photo!]!
}
```
Добавив **три кавычки выше и ниже** вашего комментария к каждому типу или полю, вы **предоставляете** пользователям **словарь для вашего API**. 

Помимо типов и полей, вы также можете документировать аргументы.  

```js
type Mutation { 
 """
 Authorizes a GitHub User
 """
 githubAuth(
 "The unique code from GitHub that is sent to authorize the user"
 code: String!
 ): AuthPayload!
}
```
Комментарии аргументов предоставляют имя аргумента и информацию о том, не является ли поле необязательным. Если вы используете типы ввода, вы можете документировать их, как и любой другой тип:

```js
"""
The inputs sent with the postPhoto Mutation
"""
input PostPhotoInput {
 "The name of the new photo"
 name: String!
 "(optional) A brief description of the photo"
 description: String
 "(optional) The category that defines the photo"
 category: PhotoCategory=PORTRAIT
}
postPhoto(
 "input: The name, description, and category for a new photo"
 input: PostPhotoInput!
): Photo!
```

Все эти комментарии затем перечисляются в документации схемы GraphQL Playground или GraphiQL

В основе всех проектов GraphQL лежит прочная, четко определенная схема. 
И это служит дорожной картой и контрактом между фронтенд- и бэкенд-командами для обеспечения того, чтобы собранный продукт всегда соответствовал схеме.
