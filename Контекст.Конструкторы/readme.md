### Контекст в JavaScript 

- [Правила определения this](#Правила_определения_this)
- [this в глобальной области видимости](#this_в_глобальной_области_видимости)
- [this в методе объекта](#this_в_методе_объекта)
- [this в методе объекта](#this_в_методе_объекта)
- [this в стрелочных функциях](#this_в_стрелочных_функциях)
- [this в локальной области видимости](#this_в_локальной_области_видимости)
- [this функциях обратного вызова](#this_функциях_обратного_вызова)
- [Методы функций call/apply/bind](#Методы_функций_call/apply/bind)
  - [.call( )](#call_и_аргументы)
  - [.apply( )](#apply_и_аргументы)
  - [.bind( )](#bind)

------------


- [Another wors](#Another_wors)
- [Альтернативное объяснение](#Альтернативное_объяснение)

------------

Контекст в JavaScript похож на контекст в предложении:

«Петя бежит быстро, потому что Петя пытается поймать поезд.»
«Петя бежит быстро, потому что он пытается поймать поезд.»

Предметом предложения является Петя, и мы можем сказать, что контекст предложения - это Петя, потому что он в центре внимания в это конкретное время в предложении. Даже местоимение «кто» относится к Пете.

И точно так же, мы можем иметь объект, который является текущим контекстом исполнения функции.

```javascript
// «Петя бежит быстро, потому что Петя пытается поймать поезд.»
const petya = {
  name: 'Petya',
  showName() {
    console.log(petya.name);
  }
};
petya.showName();
```

Обращение к свойствам объекта внутри методов, используя имя самого объекта, аналогично использованию "Петя" вместо "он".

Во-первых, надо знать, что все функции JavaScript имеют свойства, так же как объекты имеют свойства, потому что функции это тоже объекты. И когда функция выполняется, она получает свойство this - переменную со ссылкой на объект, в контексте которого вызывается функция, в которой используется this. this всегда ссылается на объект.

this нам нужен для доступа к методам и свойствам объекта, который вызывает функцию, тем более, что мы не всегда знаем, имя вызывающего объекта.

```javascript
// «Петя бежит быстро, потому что он (this) пытается поймать поезд.»
const petya = {
  name: 'Petya',
  showName() {
    console.log(this.name);
  }
};

petya.showName();
```

### Правила_определения_this

Необходимо усвоить всего одно правило для определения this: **значение this, внутри функции, определятся не в момент создания функции, а в момент ее вызова**.

Значение **this определяет то, как вызывается функция**. Несмотря на то, что кажется как будто this ссылается на объект внутри которого был определен метод объекта.

#### this_в_глобальной_области_видимости

В глобальной области видимости, контекст ссылается на объект window, если скрипт не находится в строгом режиме "use strict".

Когда мы используем строгий режим, значение this, в глобальной области видимости (в глобальных функциях и анонимных функциях), будет undefined.

```javascript
function fn() {
  console.log(this);
}

fn(); // window без "use strict" и udefined с "use strict"
```

#### this_в_методе_объекта

Если **функция** была **вызвана как метод объекта**, то **контекст** будет **ссылаться на объект, частью которого является метод**.

```javascript
const petya = {
  name: 'Petya',
  showThis() {
    console.log(this);
  },
  showName() {
    console.log(this.name);
  },
};

petya.showThis(); // {name: "Petya", showThis: ƒ, showName: ƒ}
petya.showName(); // 'Petya'
```

Более сложный пример:

сначала создадим функцию в глобальной области видимости, и вызовем ее.
после чего присвоим ее в свойство объекта и вызовем как метод этого объекта.

```javascript
function showName() {
    console.log('this in showName: ', this);
    console.log("this.name: ", this.name);
  }

  // Вызываем в глоабльном контексте
  showName();
  // this in showName: Window
  // this.name:

  const user = { name: "Mango" };
  // Записываем ссылку на функцию в свойство объекта
  // Обратите внимание, что это не вызов - нет ()
  user.show = showName;

  // Вызываем функцию в контексте объекта
  // this будет указывать на текущий объект, в контексте
  // которого осуществляется вызов, а не на глобальный объект.
  user.show();
  // this in showName: {name: "Mango", show: ƒ}
  // this.name:  Mango
```

  #### this_в_стрелочных_функциях

Для стрелочных функций в JavaScript сделано исключение. **У них отсутсвует свой this,** и поэтому **внутри стрелочных функций this определяется местом создания, а не местом вызова.**

```javascript
const showName = () => console.log('In showName: ', this);

showName(); // In showName: window

const user = { name: 'Mango' };
user.show = showName;

user.show(); // In showName: window
```

#### use strict

**Стрелочные функции игнорируют наличие строгого режима.**

```javascript
"use strict";
const fn = () => this;

console.log( fn() ); // window
```

#### this_в_локальной_области_видимости

```javascript
const hotel = {
  showThis: function () {
    const fn = () => this;
    console.log( fn() );
  }
}

hotel.showThis(); // {showThis: ƒ} 
```

Будьте **внимательны** при использовании стрелочных функций как методов объекта.

```javascript
const hotel = {
  name: "Resort Hotel",
  showName: () => console.log('this: ', this)
};

// this внутри метода созданного через стрелочную функцию
// будет всегда ссылаться на тот контекст в котором
// был создан сам объект, то есть на внешний контекст
hotel.showName(); // this:  window или undefined
```

#### this_функциях_обратного_вызова

Когда мы передаем метод, который использует this, в качестве параметра, который будет использоваться как функция обратного вызова, мы получим проблему. 

```javascript
const hotel = {
  name: "Resort Hotel",
  showThis() {
    console.log(this);
  }
};

const fn = function (callback) {
  // callback это ссылка на функцию showThis объекта user.
  // Ее вызов происходит в глобальном контексте
  // Соответственно this не будет ссылаться на hotel
  callback();
};

fn(hotel.showThis); // window
```

#### Методы_функций_call/apply/bind

Присвоение функции в качестве метода объекта может показаться хорошей идеей. Но стоит ли хранить подобные методы? Дублирование уже существующих функций в виде методов объекта будет занимать ресурсы, не принося никаких заметных выгод. Можно удалять метод после использования с помощью ключевого слова delete.

```javascript
// функция
const greet = function () {
  return `Wellcome to ${this.name}!`;
};

// объект
const hotel = { name: "Resort Hotel" };

// присвоение объекту метода
hotel.wellcome = greet;

// метод работает с this объекта
console.log( hotel.wellcome() ); // "Wellcome to Resort Hotel!"

// удаление метода из объекта
delete hotel.wellcome;

// проверяем наличие свойства(метода) у объекта
console.log("wellcome" in hotel); // false

```
Теперь представьте что у вас 150 отелей и для каждого необходимо выполнить ту же самую операцию... каждый раз когда необходимо поприветствовать нового гостя.
Нам как минимум хочется сразу вынести этот общий код в функцию, которая будет получать функцию и объект, свойству которого ее присвоить, а после вызова удалить.

JavaScript предлагает более элегантное, **готовое решение - "метод взаймы"**. 
С помощью методов **call** и **apply** можно повторить последовательность с присвоением объекту метода, выполнением этого метода и последующим удалением с помощью всего лишь одной команды.

```javascript
const greet = function () {
  return `Wellcome to ${this.name} hotel!`;
};

const hotel = { name: "Resort Hotel" };

console.log( greet.call(hotel) ); // "Wellcome to Resort Hotel!"
```

#### call_и_аргументы

```javascript
fn.call(obj, arg1, arg2, ...)
```

Запомнить правило использования call довольно легко:** метод call вызовет функцию fn передав ее this ссылку на объект obj, а также аргументы arg1, arg2,** ....

```javascript
const greet = function (guest, stars) {
  return `${guest}, welcome to ${stars}-star ${this.name}!`;
};

const hotel = { name: "Resort Hotel" };
const motel = { name: "Sunlight Motel" };

console.log( greet.call(hotel, "Mango", 5) );
// "Mango, wellcome to 5-star Resort Hotel!"

console.log( greet.call(motel, "Poly", 4) );
// "Poly, wellcome to 4-star Sunlight Motel!"
```

#### apply_и_аргументы

```javascript
fn.call(obj, [arg1, arg2, ...])
```

Метод apply полный аналог метода call за исключением того, что синтаксис вызова аргументов требует не перечисление а массив.

```javascript
const greet = function (guest, stars) {
  return `${guest}, welcome to ${stars}-star ${this.name}!`;
};

const hotel = { name: "Resort Hotel" };
const motel = { name: "Sunlight Motel" };

console.log( greet.apply(hotel, ["Mango", 5]) );
// "Mango, wellcome to 5-star Resort Hotel!"

console.log( greet.apply(motel, ["Poly", 4]) );
// "Poly, wellcome to 4-star Sunlight Motel!"
```

####  bind

В случае, **когда необходимо не вызвать функцию на месте, а передать ссылку на эту функцию**, причем **с привязанным контекстом**, call и apply не подходят. Метод bind позволяет решить эту задачу.

```javascript
const boundFn = fn.bind(obj, arg1, arg2, ...)
```

Метод bind создает копию функции fn с привязанным контекстом obj и аргументами arg1, arg2, ..., после чего возвращает ее как результат своей работы. В результате мы получаем копию функции с привязанным контекстом, которую мы можем передать куда угодно и вызвать когда угодно.

```javascript
const greet = function (guest) {
  return `${guest}, welcome to ${this.name}!`;
};

const hotel = { name: "Resort Hotel" };

const hotelGreeter = greet.bind(hotel, "Mango");

hotelGreeter(); // "Mango, wellcome to Resort Hotel!"
```

**Чаще всегда метод bind используется для привязки контекста при передаче функций обратного вызова**. 
Возьмем проблемный пример из предыдущей секции.

```javascript
const hotel = {
  name: "Resort Hotel",
  showThis() {
    console.log(this);
  }
};

const fn = function (callback) {
  // callback это ссылка на функцию showThis объекта user.
  // Ее вызов происходит в глобальном контексте
  // Соответственно this не будет ссылаться на hotel
  callback();
};

fn(hotel.showThis); // window
```

Задачу привязки контеста мы теперь можем решить используя метод **bind**, передав функцией обратного вызова копию метода с привязанным контекстом.

```javascript
const hotel = {
  name: "Resort Hotel",
  showThis() {
    console.log(this);
  }
};

const fn = function (callback) {
  callback();
};

// передаем копию метода showThis
// с контекстом привязанным к hotel
fn(hotel.showThis.bind(hotel)); // {name: "Resort Hotel", showThis: ƒ}
```


------------



#### Another_wors

- **This** в обычной функции **определяется в момент ее вызова**, обязательно должен быть **ТОТ** кто ее вызывает.(слева). **ВЫЗЫВАЮЩИЙ и будет контекстом** для этого this. 
```sass
вызывающий.функция
```

- **Значение this называется контекстом вызова** и будет определено в момент вызова функции.

- **Любая функция может иметь в себе this**. Совершенно неважно, объявлена ли она в объекте или отдельно от него. 

- Если **не передать контекст** то при сторогом режиме "use strict" вернется **undefined**, при не сторогом режиме контекстом будет глобальный объект **window** 

- **this в стрелочныx функциях определется в момент ее создания** а не в момент вызова. 
- **this в стрелочныx функциях будет брать внешний контекст**  
- если стрелочная функция объявлена глобально то this будет брать контекст глобального объекта **window**
- если стрелочная функция объявлена внутри другой функции, то this будет брать контекст функции родителя   

- **свойства-функции у объектов называют «методами» объектов**. Их можно добавлять и удалять в любой момент
- можно создавать функции и затем назначать ее как метод объекта.  

```javascript
// создадим объект без методов
const userAccount = {   
    isactive: true,
    typeaccount: private,
    money: 500
};

// создали ф-цию с this, которая отобразит значение поля money у объекта
let countMoney = function(){
    console.log(this.money);   
}

// создадим для объекта метод getUserMoney
userAccount.getUserMoney = countMoney; // передали в метод функцию которую создали ранее

// теперь можем вызвать метод и посмотреть сколько денег у пользователя
userAccount.getUserMoney();  // 500 
```

- в ES6 методы для объекта создаются просто как объявление функции (function declaration) только без слова function, сразу пишем имя функции, которое становиться именем метода

```javascript
const userAccount = {   
    isactive: true,
    typeaccount: private,
    money: 500,
    showUserStatus(){  // метод
        console.log(this.isActive);
    }
    showUserType(){ // метод
        console.log(this.typeaccount);
    }
};
```

- **методы apply и call вызываются сразу** 

- если нужно разово вызвать функцию как метод объекта и при этом не присваивать объекту эту функцию как метод, то используем **метод взаймы**. для этого используем метод apply call, которые отличаются только синтаксисом передачи дополнительных параметоров

```javascript
функция.call(объект)  // вызовет функцию как метод объекта
```

Если функция имеет параметры, то мы передаем их после объекта

```javascript
// аргументы через запятую
функция.call(объект, аргумент1, аргумент2);  

// аргументы как елементы массива
функция.apply(объект, [аргумент1, аргумент2]); 
```

- Использовать apply уместно, если мы передаем массив как аргумент. 
Метод **apply будет использовать елементы массива как каждый отдельный аргумент**.

- Метод **call посчитает сам массив как один аргумент** , с котрым можно уже работать в функции как с массивом

- если **нужно привязать контекст**(объект, того кто вызывает) к функции и затем испоользовать. то **используем метод bind**.
- **метод .bind() создает копию функции и привязывает контекст. после чего выозвращает эту копию** 

```javascript
// в переменной будет храниться копия функции с переданным контекстом
let переменная = функция.bind(контекст); 
```

Если у функции были параметры, то они передаются как и в методе call, через запятую

```javascript
let переменная = функция.bind(контекстб, аргумент1, аргумент2); 
```

------------



#### Альтернативное_объяснение

о контексте
[tproger](https://tproger.ru/translations/javascript-this-keyword/) 

[MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/this)

[learn.javascript.ru](https://learn.javascript.ru/object-methods)

[habr](https://habr.com/post/149516/)

[getinstance](https://getinstance.info/articles/javascript/execution-context/)

о методах
[getinstance](https://getinstance.info/articles/javascript/call-apply-and-bind-functions/)
