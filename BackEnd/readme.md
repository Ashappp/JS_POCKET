![pic](http://i.piccy.info/i9/1c51f2d65ef43e042435b192fdd5a9e1/1554789603/18551/1309575/6f02c72cd98df59415f8211e92570134.png)

## Протоколы передачи данных

Протокол — набор правил и соглашений, используемых при передаче данных в сети.

Перед тем как пользователь увидит содержимое сайта на экране, браузер делает запрос на сервер чтобы получить это самое содержимое. Каждый элемент приходит с сервера: html-файл, изображения, стили, скрипты. Это влияет на скорость отображения веб-страниц, поэтому необходимо как минимум представлять как эти данные браузер получает.

## TCP/IP
Основополагающий протокол сети Internet. Это два протокола тесно связанных между собой.

TCP (Transmission Control Protocol) — протокол управления передачей. Определяет, каким образом информация должна быть разбита на пакеты и отправлена по каналам связи. TCP располагает пакеты в нужном порядке, а также проверяет каждый пакет на наличие ошибок при передаче.
IP (Internet Protocol) — каждый информационный пакет содержит IP-адреса компьютера-отправителя и компьютера-получателя. Специальные компьютеры, называемые маршрутизаторами, используя IP-адреса, направляют информационные пакеты в нужную сторону, то есть к указанному в них получателю.

## HyperText Transfer Protocol (HTTP)
Браузер запрашивает и получает данные через HTTP-протокол, поэтому браузер еще называют HTTP-клиентом.

Протокол передачи гипертекста (HTTP) — специально разработанный протокол как основа World Wide Web, используется для передачи всех необходимых типов данных: html, изображений, аудио и видео, css, javascript и т. д. Дефолтный TCP-порт — 80.

HTTP основан на модели клиент-сервер и протоколе запрос-ответ, который работает путем обмена сообщениями через надежное TCP/IP соединение.

## req res cycle

Есть клиент, который инициирует соединение и посылает запрос, и сервер, который ожидает соединения для получения запроса, производит необходимые действия и возвращает обратно сообщение с результатом. Связь между ними осуществляется посредством череды перемежающихся HTTP-запросов и HTTP-ответов.

## HyperText Transfer Protocol Secure (HTTPS)
HTTPS — это надстойка над HTTP-протоколом, в которой все сообщения между клиентом и сервером шифруются в целях повышения безопасности. Обеспечивает защиту от атак, основанных на прослушивании соединения. Данные передаются поверх криптографических протоколов SSL или TLS. Дефолтный TCP-порт — 443.

- ssl

При общении через обычное HTTP-соединение все данные передаются в виде текста и могут быть прочитаны всеми, кто получил доступ к соединению между клиентом и сервером. Если пользователь делает покупки онлайн и заполняет форму заказа, содержащую информацию о кредитной карте, их финансовые данные гораздо легче украсть, если они передаются в виде текста. С HTTPS данные будут зашифрованы, и хакер не сможет их расшифровать, потому что для расшифровки необходим доступ к закрытому ключу, который хранится на сервере.

- http https protocols

Информация о клиенте, например номера кредитных карт, зашифрована и не может быть перехвачена в расшифрованом виде
Посетители могут подтвердить, что сайт безопасен, посмотрев на иконку слева от адресной строки, защещенные содеинения помечаются и иконкой замка
Клиенты с большей вероятностью будут доверять и совершать покупки с сайтов использующих HTTPS

## На что тратит время HTTP-запрос

Запрос происходит в несколько этапов:

1. DNS-запрос — поиск ближайшего DNS-сервера, чтобы преобразовать адрес (например google.com ) в его числовое представление, IP-адрес (74.125.87.99).

2. Соединение — установка соединения с сервером по полученному IP-адресу.

3. Отправка данных — пересылка пакетов с клиента на сервер.

4. Ожидание ответа — ждем пока пакеты данных дойдут до сервера, он их обработает и ответ вернется назад.
Получение данных — пакеты пришли, можно получать из них данные.


## RESTful API

Сервер — это программа, расположенная на компьютре, способная обработать HTTP-запросы на определенный адрес и имеющая набор готовых действий на определенные запросы.

- API (интерфейс прикладного программирования) — набор четко определенных правил связи между различными программными компонентами. Интерфейс описывает что можно попросить программу сделать и что получится в результате.

- REST (representational state transfer) — представляет собой стиль бекенд-архитектуры, основанный на наборе принципов, которые описывают как сетевые ресурсы определяются и адресуются.

- RESTful API — служит прослойкой между клиентом и базой данных. Имеет стандартный интерфейс для обращения к ресурсам. Работает как веб-сайт, мы посылаем HTTP-запрос с клиента на сервер, а в ответ, вместо HTML-страницы получаем запрошенные данные в JSON-формате.

 

### Формат запроса
REST-сервис требует чтобы клиент делал запрос на добавление, извлечение или изменение данных на сервере. 

Запрос обычно состоит из:

- Путь — путь к ресурсу. Доступные пути описываются в документации REST-сервиса
- HTTP-метод — определяет какую операцию выполнять
- Заголовок — позволяет клиенту передавать информацию о запросе
- Тело — дополнительный блок запроса, содержащий данные

#### HTTP-методы
Выделяют 4 основных метода для работы с REST-сервисом.

POST — создать новый ресурс
GET — получить набор ресурсов или определенный ресурс по идентификатору
PUT или PATCH — обновление определенного ресурса по идентификатору
DELETE — удаление определенного ресурса по идентификатору
HTTP-методы на MDN

#### Заголовки
Заголовки содержат служебную информацию, относящуюся к пользователю или контенту запроса, и как клиент собирается обрабатывать предоставленную ему информацию.

К примеру тип контента который клиент может обработать в ответе от сервера (заголовок Accept) или который описывает тип ресурса который клиент отправляет серверу или сервер отправляет клиенту (заголовок Content-Type).

MIME-типы — варианты типов контента. Использутся для указания содержимого зароса и ответа, состоят из типа и подтипа, которые разделены косой чертой /.

Например, текстовый файл, содержащий HTML, будет описан типом text/html. Если файл содержит CSS, он будет описан как text/css. Просто текстовый файл будет описан как text/plain. Данные в формате JSON будут представлены как application/json. Если, к примеру, клиент ожидает text/css, а получает text/plain, он не сможет распознать и обработать контент.

#### Пути
Запросы должны содержать путь к ресурсу, над которым выполняется операция. Доступные пути описываются в документации REST-сервиса.

https://bookstore.com/customers/289/orders/12
Такой путь явно указывает ресурс, даже если вы никогда раньше не видели его, потому что он является иерархическим и описательным. Мы обращаемся к заказу с идентификатором 12 для клиента с идентификатором 289.

## Коды ответов
На запрос клиента сервер отправляет ответ. Ответ содержит код состояния, чтобы информировать клиента о результате операции. Коды делятся на группы.

1XX — несут информационное назначение
2XX — коды успешного проведения операции
3XX — описывают все что связано с перенаправлением
4XX — указывают на ошибки клиента
5XX — указывают на ошибки на стороне сервера
Вам не нужно помнить каждый код состояния (их много), но вы должны знать наиболее распространенные и их значения.

200 (OK) - стандартный ответ для успешных HTTP-запросов
201 (CREATED) - стандартный ответ для HTTP-запроса, который привел к успешному созданию ресурса
400 (BAD REQUEST) - запрос не может быть обработан из-за неверного синтаксиса запроса или другой ошибки клиента.
401 (UNAUTHORIZED) - для доступа к ресурсу требуется авторизация.
403 (FORBIDDEN) - у клиента нет разрешения на доступ к этому ресурсу.
404 (NOT FOUND) - в настоящее время ресурс не найден. Возможно, он был удален или еще не существует.
500 (INTERNAL SERVER ERROR) - общий ответ на непредвиденный сбой, сервера если нет более конкретной информации.
Коды HTTP-ответов на MDN

## Запрос-Ответ
Предположим, у нас есть приложение, которое позволяет просматривать, создавать, редактировать и удалять клиентов и заказы небольшого книжного магазина, сервер которого размещен на bookstore.com/api. Используя полученные знания мы можем, псевдокодом, описать процесс запрос-ответ к REST-сервису.

Если бы мы хотели просмотреть всех клиентов, запрос будет выглядеть так:

```jsx
GET http://bookstore.com/api/customers
Accept: application/json
Ответ сервера:

Status Code: 200 (OK)
Content-Type: application/json
Для просмотра одного клиента мы указываем его идентификатор:

GET http://bookstore.com/api/customers/123
Accept: application/json
Ответ сервера:

Status Code: 200 (OK)
Content-Type: application/json
Создание нового клиента:

POST http://bookstore.com/api/customers
Content-Type: application/json
Body: {
  "name": "Mango"
  "email": "mango@gmail.com"
}
Сервер добавляет уникальный идентификатор для этого объекта и возвращает его обратно клиенту, например:

Status Code: 201 (CREATED)
Content-type: application/json
Body: {
  "id": 18674,
  "name": "Mango"
  "email": "mango@gmail.com"
}
```


# Asynchronous JavaScript and XML

### AJAX 
Метод отправки или запроса данных, с последующим обновлением интерфейса по этим данным, без необходимости перезагрузки страницы. За счет этого уменьшается время отклика и веб-страница становится более интерактивная.

Несмотря на то, что в названии технологии присутствует XML, использовать его вовсе не обязательно. Под AJAX подразумевают любое общение с сервером без перезагрузки страницы.

В пример можно привести подгрузку данных:

На веб-странице происходит событие (страница загружается, нажимается кнопка "Показать больше", отправляется форма и т. п.)
На клиенте, с помощью JavaScript, реакцией на это событие выполнятся функция для работы с сервером где создается и отправляется HTTP-запрос
Сервер получает и обрабатывает HTTP-запрос, отправляя обратно в ответе данные в JSON-формате
На клиенте, с помощью JavaScript, ответ от сервера обрабатывается, считываются данные и обновляется интерфейс

### Fetch API
Fetch API — предоставляет интерфейс, набор методов и свойств, для отправки, получения и обработки ресурсов от сервера.

Это XMLHttpRequest нового поколения. Он предоставляет улучшенный интерфейс для составления запросов к серверу и построен на обещаниях (promise).

fetch(url, options)
- url — обязательный, путь к данным которые вы хотите получить.
- options — необязатльнный, объект настроек запроса. Содержит служебную информацию: метод (по умолчанию GET), заголовки и т. д.
Возвращает промис, который содержит ответ сервера.

```jsx
fetch('https://jsonplaceholder.typicode.com/users')
  .then(response => {
    //response handling
  })
  .then(data => {
    // data handling
  })
  .catch(error => {
    // error handling
  });
```

#### Response
В первый then передается экземпляр класса **Response**, снабженный различными методами и свойствами. В нем содержится служебная информация о состоянии ответа сервера.

```jsx
fetch('https://jsonplaceholder.typicode.com/users')
  .then(response => {
    if (response.ok) return response.json();

    throw new Error(`Error while fetching: ${response.statusText}`);
  })
  .then(data => {
    // data handling
  })
  .catch(error => {
    // error handling
  });
```

### Headers

Headers — позволяет выполнять различные действия в заголовках HTTP-запроса и ответа. Эти действия включают в себя извлечение, настройку, добавление и удаление заголовков (методы append, has, get, set, delete).

```jsx
const headers = new Headers();

headers.append('Content-Type', 'text/plain');
headers.append('X-Custom-Header', 'custom value');
headers.has('Content-Type'); // true
headers.get('Content-Type'); // "text/plain"
headers.set('Content-Type', 'application/json');
headers.delete('X-Custom-Header');

Для составления заголовков запроса, если необходимы методы заголовков, можно использовать объект при вызове 

new Headers, с парами ключ:значение.

const headers = new Headers({
  'Content-Type': 'application/json',
  'X-Custom-Header': 'custom value',
});

Или просто литерал объекта со свойствами, но в таком случае методов заголовков не будет, что зачастую и не требуется.

const headers = {
  'Content-Type': 'application/json',
  'X-Custom-Header': 'custom value',
};

Запрос с использованием заголовков может выглядеть так.

fetch('https://jsonplaceholder.typicode.com/users', {
  method: 'GET',
  headers: {
    Accept: 'application/json',
  },
}).then(reponse => {});
```
 
### Вкладка Network
На вкладке Network отображаются все выполняющиеся на странице HTTP-запросы. Выбрав XHR (можно фильтровать по типу запроса) останутся только запросы к бекенду, и после нажатия кнопки, через некоторое время, отобразится запрос. Выбрав его, можно посмотреть служебную информацию и тело ответа на вкладках Headers, Preview, Response и Timing. 

### Работа с публичным RESTful API
Каждый API уникален, их тысячи, невозможно заучить код для работы с одним сервисом и использовать его для общения с другим. С другой стороны, RESTful API построены по принципам REST-архитектуры, а это значит что можно понять принцип и методы работы, после чего, все что нужно сделать — это ознакомиться с документацией того сервиса который необходимо использовать.


# Cross-Origin Resource Sharing (CORS)

Обычно HTTP-запрос можно делать только в рамках текущего сайта. При попытке использовать другой домен/порт/протокол — браузер выдаёт ошибку. Это сделано из соображений безопасности и настраивается на стороне сервера. Если сервер не поддерживает CORS-запросы, то фронтенд разработчик ничего не сможет с этим сделать в своем коде.

Общая идея заключается в следующих шагах:

1. Перед самим запросом, браузер делает preflight-запрос, информируя сервер о том, что он (бразуер) хочет сделать HTTP-запрос с такого-то адреса

2. Сервер возвращает preflight-ответ в котором разрешает или запрещает делать запрос, зависит от настроек сервера

3. Если сервер разрешил делать запрос, браузер производит оригинальный запрос и получит ответ от сервера

4. Если сервер запретил запрос, в консоли браузера можно будет видеть информацию о CORS-ошибке во время попытки запроса  


Разберем POST-запрос. 
Во время запроса, браузер может добавлять заголовок Origin, указывая на то, откуда был взят оригинальный HTML-файл.

```jsx
POST HTTP/1.1
Origin: https://webiste.api.com
Host: webiste.api.com

Тогда сервер в ответ вернет заголовок Access-Control-Allow-Origin, в котором будет указаны адреса с правами доступа к API. Значениями могут быть определенные адреса, либо * — доступ разрешен с любого адреса.

// Если API приватный то будут указаны доступные адреса
Access-Control-Allow-Origin: https://webiste.api.com

// Если API публичный, доступ будет открыт всем
Access-Control-Allow-Origin: *
```

# CRUD — создание (create), чтение (read), обновление (update) и удаление (delete), четыре основные метода для взимодействия с ресурсами RESTful API.

В REST-архитектуре, CRUD соответствует соответствует HTTP-методам:

POST (create) — создать новый ресурс
GET (read) — получить набор ресурсов или определенный ресурс по идентификатору
PUT (update) или PATCH (update) — обновление ресурса по идентификатору
DELETE (delete) — удаление ресурса по идентификатору

Допустим наш API хранит массив постов, каждый из которых это объект со следующими полями.

```jsx
"post": {
  "id": <Integer>,
  "author": <String>,
  "body": <String>,
}
```

В примерах используем JSONPlaceholder, REST API для прототипирования.

- Создание (create, POST)

Происходит когда мы хотим добавить новый ресурс (пост). Функция которая будет это делать, должна отправить на сервер запрос, в теле которого будет объект с полями author и body. RESTful API, по получению запроса, добавит объекту id и в ответе вернет этот ресурс.

```jsx
const postToAdd = {
  author: 'Mango',
  body: 'CRUD is awesome',
};

fetch('https://jsonplaceholder.typicode.com/posts', {
  method: 'POST',
  body: JSON.stringify(postToAdd),
  headers: {
    'Content-Type': 'application/json; charset=UTF-8',
  },
})
  .then(response => response.json())
  .then(post => console.log(post))
  .catch(error => console.log(error));
В ответ, если все хорошо, получим объект с добавленным id

{
  id: 1, // идентификатор будет уникальным для каждого поста
  author: 'Mango',
  body: 'CRUD is awesome',
}
```

- Чтение (read, GET)

Происходит когда мы хотим получить существующие данные. Функция которая будет это делать, должна отправить на сервер запрос, без тела. RESTful API, по получению запроса, обработает его и в ответе вернет необходимые ресусрсы.

Просим все посты.
```jsx
fetch('https://jsonplaceholder.typicode.com/posts')
  .then(response => response.json())
  .then(posts => console.log(posts))
  .catch(error => console.log(error));
Просим один пост по id, к примеру пост с id = 1.

const postId = 1;

fetch(`https://jsonplaceholder.typicode.com/posts/${postId}`)
  .then(response => response.json())
  .then(post => console.log(post))
  .catch(error => console.log(error));
```

- Обновление (update, PUT и PATCH)

Происходит когда мы хотим обновить существующие данные. Функция которая будет это делать, должна отправить на сервер запрос, в теле которого необходимо указать объект с полями для изменения. RESTful API, по получению запроса, обработает его и в ответе вернет обновленный ресурс.

```jsx
const postToUpdate = {
  id: 1,
  author: 'Mango',
  body: 'CRUD is really awesome',
};

fetch(`https://jsonplaceholder.typicode.com/posts/${postToUpdate.id}`, {
  method: 'PUT',
  body: JSON.stringify(postToUpdate),
  headers: {
    'Content-Type': 'application/json; charset=UTF-8',
  },
})
  .then(response => response.json())
  .then(post => console.log(post))
  .catch(error => console.log('ERROR' + error));
В ответ, если все хорошо, получим обновленный объект.

{
  id: 1,
  author: 'Mango',
  body: 'CRUD is really awesome',
}
```

- Удаление (delete, DELETE)

Происходит когда мы хотим удалить существующие данные. Функция которая будет это делать, должна отправить на сервер запрос, без тела. RESTful API, по получению запроса, обработает его, удалит ресурс из коллекции, и в ответе вернет статус результата.

```jsx
const postIdToDelete = 1;

fetch(`https://jsonplaceholder.typicode.com/posts/${postIdToDelete}`, {
  method: 'DELETE',
})
  .then(() => console.log('success'))
  .catch(error => console.log('ERROR' + error));
```
