EVENT 
- [addEventListener](#addEventListener)
- [removeEventListener](#removeEventListener)
 - [this и addEventListener](#this_и_addEventListener)
- [Объект события EVENT](#Объект_события_EVENT)
- [Всплытие событий](#Всплытие_событий)
 - [this и event.target](#this_и_event.target)
- [Прекращение всплытия](#Прекращение_всплытия)





Произошедшие браузер записывает в **«объект события»**, который передаётся **первым аргументом** в обработчик.

- **click**	происходит, когда кликнули на элемент левой кнопкой мыши
- **submit**	посетитель отправил форму
- **focus**	посетитель фокусируется на элементе, например нажимает на input
- **keydown**	когда посетитель нажимает клавишу
- **keyup**	когда посетитель отпускает клавишу
- **DOMContentLoaded**	когда HTML загружен и обработан, DOM документа полностью построен и доступен

Для того чтобы **элемент** интерфейса **реагировал на действия** пользователя, на него **необходимо повесить обработчик** (слушателя) события, то есть **функцию, которая сработает, как только событие произошло.** 
Именно благодаря обработчикам JavaScript-код может реагировать на действия посетителя.

Методы **addEventListener** и **removeEventListener** являются современным способом назначить или удалить обработчик, и при этом позволяют использовать сколько угодно обработчиков.

------------


### addEventListener

```javascript
element.addEventListener(event, handler[, phase]);
```
- **event**	Имя события, например click, передается как строка
- **handler**	Ссылка на функцию, которую надо поставить обработчиком
- **phase**	Необязательный аргумент, «фаза», на которой обработчик должен сработать.  true - захват false-всплытие 

### removeEventListener

**Удаление** обработчика осуществляется вызовом removeEventListener. Аргументы те же что у addEventListener.

Для удаления нужно передать **именно ту функцию**-обработчик которая была назначена в addEventListener. 
**Поэтому часто для callback используют отдельную функцию и передают ее по имени.**

```javascript
element.removeEventListener(event, handler);
```

------------


### this_и_addEventListener

Если мы передаем функцию которая использует this, то **по умолчанию this внутри нее будет ссылаться на сам DOM-узел** на котором висит addEventListener. Не забывайте привязывать контекст используя bind.

```javascript
btn.addEventListener('click', user.showName); // не работает
btn.addEventListener('click', user.showName.bind(user)); // работает
```

------------


### Объект_события_EVENT

Объект события содержит ценную информацию о деталях события. 
Он автоматически передается первым аргументом в обработчик события.

```javascript
event.type	//Тип события, например click
event.currentTarget	//Элемент, на котором сработал обработчик.  
event.clientX и event.clientY	//Координаты курсора в момент клика (относительно окна)
```

------------


### Всплытие_событий

Сразу скажем, существуют** 3 фазы** события:

1. **capturing **phase - событие начинается на window и **тонет** до самого глубокого целевого элемента
2. **target** phase - событие **дошло** до самого глубокого целевого элемента
3. **bubbling** phase - событие **всплывает** от самого глубокого целевого элемента до window

Основной принцип всплытия - при наступлении события обработчики сначала срабатывают на самом вложенном элементе, затем на его родителе, затем выше и так далее, вверх по цепочке вложенности. Всплывают почти все события. Например, событие focus не всплывает.

### this_и_event.target

Целевой элемент (event.target) - на каком бы элементе мы ни поймали событие, всегда можно узнать где конкретно оно произошло. Самый глубокий элемент, который вызывает событие, называется «целевым» или «исходным» элементом и доступен как event.target.

Отличия от this (event.currentTarget):

- **event.target** – это **ссылка** исходный элемент, на котором **произошло событие**, в процессе всплытия он неизменен.

- **this** – это текущий элемент, до которого **дошло всплытие**, на нём сейчас выполняется обработчик. 
Если callback был стрелочной функцией то this будет другим. 
В стрелочных функция для получения элемента на котором произошел обработчик используется event.currentTarget.

Если стоит только один обработчик на самом верхнем элементе, то он «поймает» все клики внутри родителя. Где бы ни был клик внутри – он всплывёт до элемента-родителя, на котором сработает обработчик.

------------


### Прекращение_всплытия

##### stopPropagation

Всплытие идёт прямо наверх. Обычно событие будет всплывать наверх и наверх, до элемента html, а затем до document, а иногда даже до window, вызывая все обработчики на своем пути. Но любой промежуточный обработчик может решить, что событие полностью обработано, и остановить всплытие. 
Для остановки всплытия нужно вызвать метод event.stopPropagation().

##### stopImmediatePropagation

Если у элемента есть несколько обработчиков на одно событие, то даже при прекращении всплытия все они будут выполнены. То есть, stopPropagation препятствует продвижению события дальше, но на текущем элементе все обработчики отработают. 
Для того, чтобы полностью остановить обработку, современные браузеры поддерживают метод event.stopImmediatePropagation(). Он не только предотвращает всплытие, но и останавливает обработку событий на текущем элементе.

------------


#### Делегирование_событий

Он заключается в том, что если у нас есть много элементов, события на которых нужно обрабатывать похожим образом, то вместо того, чтобы назначать обработчик каждому – мы ставим один обработчик на их общего предка. Из него можно получить целевой элемент event.target, понять на каком именно потомке произошло событие и обработать его.

Делегирование (event delegation) – это средство оптимизации интерфейса. Мы используем один обработчик для схожих действий на однотипных элементах.

**Алгоритм использования**:

1. Вешаем обработчик на контейнер.
2. В обработчике: получаем event.target.
3. В обработчике: если event.target или один из его родителей в контейнере ( this) – интересующий нас элемент – обработать его.

**Зачем использовать**?

- Упрощает инициализацию и экономит память: не нужно вешать много обработчиков.
- Меньше кода: при добавлении и удалении элементов не нужно ставить или снимать обработчики.
- Удобство изменений: можно массово добавлять или удалять элементы путём изменения innerHTML.

#### Действия_браузера_по_умолчанию

Многие события автоматически влекут за собой действие браузера. Браузер имеет встроенные действия при ряде событий – переход по ссылке, отправка формы и т.п. Как правило, их можно отменить.

Например:

- Клик по ссылке инициирует переход на новый URL.
- Нажатие на кнопку «отправить» в форме – отсылку ее на сервер.
- Двойной клик на тексте – инициирует его выделение.

Основной способ это воспользоваться объектом события. 
Для отмены действия браузера существует стандартный метод **event.preventDefault().**

### Загрузка документа
Когда мы открываем веб-страницу, процесс загрузки HTML-документа, условно, состоит из трёх стадий. Все эти стадии очень важны. На каждую можно повесить обработчик, чтобы совершить действия

- **DOMContentLoaded** – браузер полностью загрузил HTML и построил DOM-дерево.
- **load** – браузер загрузил все ресурсы.
- **beforeunload/unload** – уход со страницы.

**DOMContentLoaded**

Событие **DOMContentLoaded происходит на document**. Означает, что все DOM-элементы разметки уже созданы, можно их искать, вешать обработчики, создавать интерфейс, но при этом, возможно, ещё не догрузились какие-то картинки или стили.

Если в документе есть теги script, то браузер обязан их выполнить до того, как построит DOM. Поэтому событие DOMContentLoaded ждёт загрузки и выполнения таких скриптов. Исключением являются скрипты с атрибутами async и defer, которые подгружаются асинхронно.

Внешние файлы стилей никак не влияют на событие DOMContentLoaded.

```javascript 
document.addEventListener("DOMContentLoaded", callback);
```
**onload**

Событие onload срабатывает на window, когда загружается вся страница, включая ресурсы на ней – стили, картинки и т.д. Его используют редко, поскольку обычно нет нужды ждать загрузки всех ресурсов.

**onunload**

Когда человек уходит со страницы или закрывает окно, на window срабатывает событие unload. В нём можно сделать что-то, не требующее ожидания, например, закрыть вспомогательные popup-окна, но отменить сам переход нельзя. Событие почти не используется, как правило, оно бесполезно – мало что можно сделать, зная, что окно браузера прямо сейчас закроется.

**onbeforeunload**

window.onbeforeunload – это де-факто стандарт для того, чтобы проверить, сохранил ли посетитель данные, действительно ли он хочет покинуть страницу. Если посетитель инициировал переход на другую страницу или нажал «закрыть окно», то обработчик onbeforeunload может приостановить процесс и спросить подтверждение. Для этого ему нужно вернуть строку, которую браузеры покажут посетителю, спрашивая – нужно ли переходить.
