# JSX

JSX это расширенние языка js, которое позволяет писать шаблоны HTML с подстановкой js выражений (корректный блок кода, который возвращает значение).
Описывает елемненты.
Babel транспилирует jsx код в вызов React.createElement(), в конечной итоге jsx преобразуется в объект, поэтому его можно присваивать и возвращать из функций.

Трансформация JSX в объект JS

```jsx
// 1. ----- описываем елемент используя JSX
const element = (
  <h1 className="greeting">
    Hello, world!
  </h1>
);

// 2. ----- Babel , вызывает React.createElement
const element = React.createElement(
  'h1',
  {className: 'greeting'},
  'Привет, мир!'
);

// 3. ----- React.createElement() создаёт такой объект

const element = {
  type: 'h1',
  props: {
    className: 'greeting',
    children: 'Привет, мир!'
  }
};

В конечном итоге в переменной element лежит js объект
```

# Рендеринг Элементов

Элемент описывает то, что вы хотите увидеть на экране, это DOM-теги

В отличие от DOM-элементов, элементы React — это простые js объекты (без многих методов)

Для рендеринга React-элемента в корневой узел DOM, вызоваем ReactDOM.render()

```jsx
const element = <h1>Hello, world</h1>;
ReactDOM.render(element, document.getElementById("root"));
```

Элементы React иммутабельны. После создания элемента, нельзя изменить его потомков или атрибуты.

React DOM сравнивает элемент и его дочернее дерево с предыдущей версией и вносит в DOM только минимально необходимые изменения.

# Компоненты и пропсы

Компоненты возвращают jsx елементы.

Компоненты позволяют разбить интерфейс на независимые части, про которые легко думать в отдельности

Всегда называйте компоненты с заглавной буквы.

Если компонент начинается с маленькой буквы, React принимает его за DOM-тег.

Компоненты ведут себя как обычные функции JavaScript.

React-компоненты обязаны вести себя как чистые функции по отношению к своим пропсам

Они принимают произвольные входные данные (так называемые «пропсы») и возвращают React-элементы, описывающие, что мы хотим увидеть на экране.

- Функциональный компонент

  - нет состояния
  - нет метода render
  - пропсы получаем как параметр
  - доступ пропсам как props.value
  - быстрее чем классовые компоненты за счет легкости и отсутствия методов жизненного цикла
  - возможность использовать хуки
  - нельзя присвоить атрибут ref, потому что не создается екземпляр

```jsx
const Welcome = props => {
  return <h1>Привет, {props.name}</h1>;
};
```

- Классовый компонент

```jsx
class Welcome extends React.Component {
  render() {
    return <h1>Привет, {this.props.name}</h1>;
  }
}
```

Метод constructor — специальный метод, необходимый для создания и инициализации объектов, созданных, с помощью класса.

В классе может быть только один метод с именем constructor.

Если класс наследуется от другого класса, то самым первым в методе сonstructor должен вызываться метод super который используется для вызова конструктора родительского класса.

Ключевое слово static, определяет статический метод для класса, который не доступен экземпляру класса

- Пропсы можно только читать

Компонент никогда не должен что-то записывать в свои пропсы — вне зависимости от того, функциональный он или классовый.

```jsx
const Welcome = props => {
  return <h1>Привет, {props.name}</h1>;
};
```

Эта функция — компонент, потому что она получает данные в одном объекте («пропсы») в качестве параметра и возвращает React-элемент.

Мы будем называть такие компоненты «функциональными», так как они буквально являются функциями.

# Состояние и его изменение

- Состояние может быть только у классовых компонетов.

- Состояние нельзя изменять/мутировать напрямую.
- Исключение- состояние напрямую можно изменить только в конструкторе this.state.key = 'newValue'

- Всегда нужно возвращать новый объект, который перезапишет старый

- React группирует/ждет все вызовы setState только после этого обновляет/перерендеривает DOM

- Для того чтобы увидеть сделанные изменения нужно сообщить React об этом вызовом метода setState

- setState - это асинхронная операция, это запрос на обновление компонента

- setState() всегда приводит к повторному рендеру, если только shouldComponentUpdate() не возвращает false

- в setState зашита логика Object.assign({}, ...oldState, ...newState)

- Обновление состояния объединяется
  setState({key:value}) объединяет аргумент (новое состояние) с текущим состоянием. Если в стейте несколько полей, то вызвов setState обновит в стейте только то поле, которое было передано аргументом при вызове setState

- Если новое состояние основывается на предыдущем состоянии + других значениях, то тогда в методе setState вызываем колбек функцию первым параметром, которая получает на вход текущий стейт

```jsx
// state — ссылка на состояние компонента при изменении
this.setState((state, props) => {
  return { counter: state.counter + props.step };
});
```

- Если нужно использовать обновленное состояние сразу то

  - используем возможность второго параметра метода setState - это колбэк, который выполняется после того, как исполнится setState и произойдёт повторный рендер компонента.
  - вызывать такие операции в componentDidUpdate()
  - использовать конструкцию async/await

- Компонент может передавать свое состояние другим компонентам в виде пропсов

- Принудительный перерендер - это вызов forceUpdate()
  forceUpdate приведёт к выполнению метода render() в компоненте, пропуская shouldComponentUpdate(). Это вызовет обычные методы жизненного цикла для дочерних компонентов, включая shouldComponentUpdate() каждого дочернего компонента

# Жизненный цикл компонента

## Mounting

1. Первым при инициализации идет **constructor()** из класса

2. Затем **getDerivedStateFromprops(nextProps, prevState)** - это статический метод, который инициализирует стейт от пропов. практически не используется

3. Метод **render()** , вызываются все createElement , Babel транспилирует JSX в JS и возвращает виртуальный дом, т.е каким он должен быть

4. После того как виртуальный дом готов , вызывается **componentDidMount**. На этом этапе уже DOM существует.

Обычно в этом методе делаются

- AJAX запросы
- навешиваем слушателей событий
- производятся операции с DOM API

## Updating

Перерендер компонента происходит в 2 случаях

- Обновление PROPS
- Обновление STATE

При наступлении одного из этих условий вызывается метод

1. **shoudComponentUpdate(nextProps, nextState)**

Вызывается для оптимизиции.

Он принимает новые props и новый state и сравнивает их c текущими.

Если они отличаюся то метод возвращает TRUE и вызывается метод render() и компонент перерендеривается, и наоборот если пропсы и стейт одинаковые то и сымсла перерендервать компонент нет

2. **getSnapshotBeforeUpdate(prevProps, prevState)**

Этот метод вызывается когда все готово для того чтобы отобразить в DOM
Можно получать значения из DOM перед обновой
Возвращаемое значение этого метода попадет в третий параметр componentDidUpdate

3. **componentDidUpdate(prevProps, prevState, snapshot)**

После того как компонент обновился вызывается этот метод
В этом методе можно вызывать setState
Делать AJAX запросы

## Unmount

1. **componentWillUnmount()**

Когда компонент удаляется из DOM, то вызывается этот метод.
Используется для очистки от слушателей, таймеров и прочего барахла

---

# React Events

- Synthetic Events - это обертка над нативным событием браузера, отличие в том , что synthetic event работает одинаково во всех браузерах (кроссбраузерность)

- События именуются в стиле camelCase вместо нижнего регистра.

- Если не пользоваться синтаксисом полей класса, то тогда обработчики необходимо БИНДИТЬ в конструкторе

- Аргументы в обработчик передаются через колбек `{()=> this.handleClick(arg)}`

# Списки и ключи

- Ключ» — это специальный строковый атрибут, который нужно указывать при создании списка элементов.

- Ключи помогают React определять, какие элементы были изменены, добавлены или удалены

- Ключ нужно определять внутри перебираемой сущности (массива)

- Ключи внутри массива должны быть уникальными только среди своих соседних элементов. Им не нужно быть уникальными глобально. Можно использовать один и тот же ключ в двух разных массивах.

- Ключи служат подсказками для React, но они никогда не передаются в ваши компоненты

# Формы

- В HTML элементы формы, такие как <input>, <textarea> и <select>, обычно сами управляют своим состоянием и обновляют его когда пользователь вводит данные

- Не контроллируемый комп. значит, что его значение будет браться из DOM, то , что введет пользователь

- В React компоненты должны быть контролируемымы, тоесть брать свое значение из состояния, которое есть удинственным источником правды

- В React мутабельное состояние обычно содержится в свойстве компонентов state и обновляется только через вызов setState()

- Если источником истины для компонентов формы будет DOM браузера, а не React state, то при изменении полей инпута если нужно отобразить изменения они не произойдут, т.к. React обновляет интерфейс в зависимости от стейта и пропсов

-
