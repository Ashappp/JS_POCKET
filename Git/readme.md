`git show` - инфа о коммите

- если мы добавили с помощью `git add .` и обнаружилось что попала ненужная папка или файл, то отменить можно с помомщью команды `git reset HEAD файл/папка`

- один коммит описывает **ОДНУ** реализацию

### Добавление

Двухступенчатый способ добавления данных

1. классический - `git add . && git commit -m 'text'`
2. быстрый - с с применением флага `-а`.

- добаляет файлы в индекс
- и делает коммит

`git commit -a` - без сообщения
`git commit -am` - с сообщением

Добавляет только те файлы которые уже были добалены в индекс, те которые находятся в рабочей директории добавлены не будут.

Индекс хранит записи о всех файлах которые были в него добавлены

### Удаление

Если файл удален , то нужно его удалить из записей индекса выполнив `git add .`

- Удаление из индекса и рабочей директории
  `git rm файл` - удаляет файл из рабочей директории и добавляет изменения в индекс
  `git rm -r папка` - удаляет папку из рабочей директории и добавляет изменения в индекс

- Удаление только из индекса
  `git rm -r --cashed папка` - удалить только из индекса. Обычно для файлов которые необходимо оставить в рабочей директории

- Удаление принудительно, если git не дает удалить иным способом
  `git rm -f файл` - файл будет удален из индекса и из рабочей директории. применяется к тем файлас которые не были добалены в репозиторий(локальный)

Если мы переименовали файл, то git воспринимает это как удаление и покажет что файл удален и в тоже время , что появился новый файл, которого нет в индексе
Выполнив добавление `git add .` гит увидит что произошло переименование

### Переименование

`git mv index.html index2.html` - **переименует в рабочей директории** index.html на index2.html **и добавит эту информацию в индекс**

### Ветки

Ветка это ссылка на коммит

Указатель `HEAD` находится на активной ветке

При первом коммите создается ветка по умолчанию `master`

Когда мы делаем последующий коммит то гит смотрит на уазатель HEAD, определяя где мы сейчас.

Когда совершается коммит то записывается история о родителе, т.е о предыдущем идентиф.коммита, на базе которого он создан.

После того как новый коммит создан , записывается новый идетификатор коммита и указатель HEAD переключается на него.

Последний коммит в ветке называется **вершиной**

При создании, новая ветка будет указывать на тот же коммит что и родитель.

Тоесть находясь в ветке `master` мы создаем новую ветку `new branch` которая будет ссылаться на тот же идентификатор что и `master`. Указатель `HEAD` находится на стороне активной ветки.

Создание новой ветки ни что иное как просто создание новой ссылки нак коммит.

При переключении на ветку происходит и перемещение указателя `HEAD` на нее.

При создании нового коммита происходит смещение ветки которая ссылается на него.

При работе в текущей ветке, если нужно отменить сделанные изменения с момента последнего коммита и вернуться в то состояние с которого начинали то выполняем `git checkout -f`

Если при работе необходимо переключиться на другую ветку и **ФАйЛЫ В ВЕТКАХ ОТЛИЧАЮТСЯ** а изменения в настоящее время нет необходимости коммитить то

- `git stash` - соберет изменения в архив и позволит переключится на другую ветку
- `git checkout -f имя ветки` - переключится ринудительно, но изменения сделанные в ветке из которой переключились/в которой работали пропадут

Ситуация:
Если сделали коммиты в ветке в которой не следовало это делать, например в `master`.
Для решения этого нужно

- создать новую ветку `git branch имя`
- сдвинуть ветку `master` к тому коммиту откуда накосячили `git branch -f master идентиф.коммита`, что переместит ветку на указанный коммит или если такой ветки нет, то создаст ее и переместит к этому коммиту. также можновоспользоваться командой `git checkout -B master идентиф.коммита`

команды
`git branch` - показ текущей ветки
`git branch имя_ветки` - создаст новую ветку
`git branch -b имя ветки` - создание новой ветки и переключение на нее
`git branch -v` - п
`git branch -a`

`git checkout -f` - возврат к состоянию последнего коммита
`git branch -f master идентиф.коммита` - переместит ветку на указанный коммит или если такой ветки нет то создаст ее
`git checkout -B master идентиф.коммита` - переместит ветку на указанный коммит или если такой ветки нет то создаст ее и переключится

### Путешествия HEAD

HEAD это указатель, который обычно указывает на активную ветку, которая в свою очередь является ссылкой на коммит.
Можно двигать указатель отдельно от ветки.

`git branch идентиф.коммита` - сдвинет HEAD к этому коммиту.

Это состояние называется `detached HEAD`.

При новом коммите ответвление произойдет от того коммита на котором сейчас находится HEAD, но это ответвление не принадлежит ни одной ветке, что означает непригодность для разработки.

Чтобы передать такой коммит в ветку нужно

- перейти в нужную ветку и вызвать `git cherry-pick идентиф.коммита` , эта команда скопирует сироту-коммит в эту ветку

#### Восстановление предыдущих версий файлов

- Ситуация: 
Получить **версию конкретного файла , на состояние конкретного коммита,** например несколько коммитов назад 

`git checkout идентиф.коммита имя_файла` 
`git checkout 54a4 index.html`  - вытаскивает файл или папку с содежимым на момент указанного коммита. 
Такой восстановленный файл git также добавляет и в индекс.
Если в такой ситуации выполнить команду `git commit` то восставновленный файл войдет в состав коммита.
Если нам такое поведение не подходит, то можно убрать восстановленый файл из текущего индекса выполнив 
`git reset имя_файла`  - удалит из индекса указанный файл

- Ситуация:
Пишем код, затем нужно **вернуть состояние файла на момент текущего коммита**
`git checkout HEAD имя_файла` - откатит код файла на состояние начала текущего коммита.
Либо короче, НЕ УКАЗЫВАЯ КОММИТ, вернет состояние файла из индекса.
`git checkout имя_файла` - откатит код файла на состояние начала текущего коммита.

#### Просмотр истории 

`git log `
`git log --oneline`
`git show индентиф.коммита` - если не передать ид.коммита то покажет текущий
`git show HEAD~` - покажет РОДИТЕЛЯ коммита
`git show HEAD~~` - покажет ДЕДА
`git show HEAD~ --quiet` с флагом `--quiet` покажет компактный вид  

**Каждый символ `~` будет идти от тукущего коммита вниз** 
Для удобства, чтобы не писать много символов `~` , их количество обохначают числом.
`git show HEAD~3` - опустимся на 3 коммита вниз.
А если не хотим каждый раз писать `HEAD` то можно заменить на символ `@`
`git show @~5` - опустимся на 5 коммитов вниз

Ситауция: 
**Посмотреть содержимое файла в конкретном коммите**
`git show @~:index.html` - после `HEAD~` нужно поставить `:` и имя фйла который хотим посмотреть 

#### Слияние перемоткой

`git merge имя_ветки` - сливаем ветку указанную после merge в ветку на которой сейчас находимся. иными словами сместит указатель на коммит ветки которую сливаем

Команда `merge` перед перемещением указателя записывает предыдущий идентификатор в директорию `.git/ORIG_HEAD`
`cat .git/ORIG_HEAD` - покажет предыдущий индентификатор коммита

Откатиться назад после `merge`
`git branch -f ORIG-HEAD` - вернет ветку в которую сливали в состояние до слияния

Второй вариант слияния 
`git checkout -B master имя_ветки` - переместит ветку на указанный коммит (ветка ни что иное как ссылка на коммит) или если такой ветки нет то создаст ее и переключится

#### Удаление веток

`git branch -d имя_ветки` - удалит ветку , при условии что она была смерджена. 
Если ветка смерджена не была, то git выбросит предупреждение.
В осознанной ситуации, когда ветка с коммитами действительно не нужна и может быть удалена используем эту же комманду с флагом `-D`
`git branch -D имя_ветки` - удалит ветку без всяких предупреждений

Обе комманды удаляют ссылку на коммиты, который помечаются как **непостежимые**. 
Такие коммиты git периодически безвозвратно удаляет.

Ситуация:
Восстановить удаленную ветку.
Если мы удалили ветку, а затем поняли, что это было ошибкой, и если прошло немного времени, то удаленные коммиты можно воостановить.
Ветка не восстанавливается, мы создаем новую ветку и устанавливаем для нее ссылку на тот коммит на который указывала удаленная ветка. 
`git checkout имя_ветки ид.коммита` или `git branch имя_ветки ид.коммита`- создаст новую ветку и установит ссылку на коммит


#### Рефлог

Все операции связанные с перемещением/удалением ссылок(веток) на коммиты, git записывает в файл logs

`cat .git/logs/HEAD` - покажет путешествие HEAD
`git reflog` -покажет путешествие HEAD
`git reflog имя_ветки` - покажет операции с веткой

В основном reflog нужен для нахождения нужных коммитов.
`git reflog --date=iso` - вывод с датами

Рефлоги хранит историю последних 90 дней
Непостежимые коммиты 30 дней

`git checkout @{-1}` - переключится на обратно на ветку с которой пришли. чтобы не писать имя ветки с которой переключилсь. цифра означает количество обратных переключений



`git fsck -unreachable`
`git gc` - почистит недостижимые коммиты

### Теги

Это еще один вид ссылки на коммит. Никуда не девается, прикрепляется к коммиту.

`git tag имя_тега и идент.коммита`
`git tag v.1.00 4c54w` - установит ярллык v.1.00 для комиита с 4c54w
`git tag` - показ всех тегов
`git tag -n`
`git show имя_тега`
`git log --oneline имя_тега`
`git tag -d имя_тега` - удалить тег

Теги бывают
- легкие 
- с аннотиацией 
`git tag -a -m 'текст аннотации' v.1.0.0 45c6` 

Если нужно получить информацию о теге зная коммит
`git describe идент.коммита` - покажет ближайщий к этому коммиту тег


### RESET

#### --hard

- Вернуться к состоянию начала коммита
`git reset --hard` - мы писали, писали и поняли что это все дерьмо и решили вернуться на исходную

- Откатиться назад 
`git reset --hard индент.коммита` - передвинет указатель на указанный коммит и обновляет рабочую диреткорию и индекс данными этого коммита

Если просто откатиться на один или несколько коммитов назад то можем писать сокращеннуб форму
`git reset --hard @~` - **@** это текущее положение **~** на один уровень вниз

Если откатились и продолжили работу , но возникла ситуация в которой необходмо вернуться на тот коммит с которого откатывались 

Если вернуться нужно **сразу**, тоесть между откатами нет других коммитов то можем воспользоваться
`git reset --hard ORIG_HEAD` - в ORIG-HEAD лежит инфа о предыдущем коммите 

Если **уже накоммитили** то
`git reflog имя_ветки` - найдем тот коммит который нам нужен
`git reset --hard индетиф.коммита` - вернемся на указынный коммит

#### --soft


----------------- continue ---------------

### REBASE

Перебазирование указателя на последний коммит веткии родителя, для того чтобы забрать последние изменения с ветки. 
Ответвление пойдет с последнего коммита ветки родителя.

`git rebase имя_ветки`
`git rebase --continue`
`git rebase --abort`
`git rebase --quit`
`git rebase --skip`

Ситуация: 
Сделали rebase но затем решили отменить rebase

Информация с какого коммита мы ушли храниться в как и раньше в 
`cat .git/ORIG_HEAD` 

но лучше проверить вот так

`git reflog имя_ветки -1` - -1 покажет последнюю запись, если нужен полный список то указываем команду без -1

`git show --quiet имя_ветки @{1}` - получить информацию о последнем коммите в этой ветке, аналог ORIG_HEAD


После того как с коммитом определились выполняем
`git reset --hard идентиф.коммита`




