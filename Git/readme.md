`git show` - инфа о коммите

- если мы добавили с помощью `git add .` и обнаружилось что попала ненужная папка или файл, то отменить можно с помомщью команды `git reset HEAD файл/папка`

- один коммит описывает **ОДНУ** реализацию

### Добавление

Двухступенчатый способ добавления данных

1. классический - `git add . && git commit -m 'text'`
2. быстрый - с с применением флага `-а`.

- добаляет файлы в индекс
- и делает коммит

`git commit -a` - без сообщения
`git commit -am` - с сообщением

Добавляет только те файлы которые уже были добалены в индекс, те которые находятся в рабочей директории добавлены не будут.

Индекс хранит записи о всех файлах которые были в него добавлены

### Удаление

Если файл удален , то нужно его удалить из записей индекса выполнив `git add .`

- Удаление из индекса и рабочей директории
  `git rm файл` - удаляет файл из рабочей директории и добавляет изменения в индекс
  `git rm -r папка` - удаляет папку из рабочей директории и добавляет изменения в индекс

- Удаление только из индекса
  `git rm -r --cashed папка` - удалить только из индекса. Обычно для файлов которые необходимо оставить в рабочей директории

- Удаление принудительно, если git не дает удалить иным способом
  `git rm -f файл` - файл будет удален из индекса и из рабочей директории. применяется к тем файлас которые не были добалены в репозиторий(локальный)

Если мы переименовали файл, то git воспринимает это как удаление и покажет что файл удален и в тоже время , что появился новый файл, которого нет в индексе
Выполнив добавление `git add .` гит увидит что произошло переименование

### Переименование

`git mv index.html index2.html` - **переименует в рабочей директории** index.html на index2.html **и добавит эту информацию в индекс**

### Ветки

Ветка это ссылка на коммит

Указатель `HEAD` находится на активной ветке

При первом коммите создается ветка по умолчанию `master`

Когда мы делаем последующий коммит то гит смотрит на уазатель HEAD, определяя где мы сейчас.

Когда совершается коммит то записывается история о родителе, т.е о предыдущем идентиф.коммита, на базе которого он создан.

После того как новый коммит создан , записывается новый идетификатор коммита и указатель HEAD переключается на него.

Последний коммит в ветке называется **вершиной**

При создании, новая ветка будет указывать на тот же коммит что и родитель.

Тоесть находясь в ветке `master` мы создаем новую ветку `new branch` которая будет ссылаться на тот же идентификатор что и `master`. Указатель `HEAD` находится на стороне активной ветки.

Создание новой ветки ни что иное как просто создание новой ссылки нак коммит.

При переключении на ветку происходит и перемещение указателя `HEAD` на нее.

При создании нового коммита происходит смещение ветки которая ссылается на него.

При работе в текущей ветке, если нужно отменить сделанные изменения с момента последнего коммита и вернуться в то состояние с которого начинали то выполняем `git checkout -f`

Если при работе необходимо переключиться на другую ветку и **ФАйЛЫ В ВЕТКАХ ОТЛИЧАЮТСЯ** а изменения в настоящее время нет необходимости коммитить то

- `git stash` - соберет изменения в архив и позволит переключится на другую ветку
- `git checkout -f имя ветки` - переключится ринудительно, но изменения сделанные в ветке из которой переключились/в которой работали пропадут

Если сделали коммиты в ветке в которой не следовало это делать, например в `master`.
Для решения этого нужно

- создать новую ветку `git branch имя`
- сдвинуть ветку `master` к тому коммиту откуда накосячили `git branch -f master идентиф.коммита`, что переместит ветку на указанный коммит или если такой ветки нет, то создаст ее и переместит к этому коммиту. также можновоспользоваться командой `git checkout -B master идентиф.коммита`

команды
`git branch` - показ текущей ветки
`git branch имя_ветки` - создаст новую ветку
`git branch -b имя ветки` - создание новой ветки и переключение на нее
`git branch -v` - п
`git branch -a`

`git checkout -f` - возврат к состоянию последнего коммита
`git branch -f master идентиф.коммита` - переместит ветку на указанный коммит или если такой ветки нет то создаст ее
`git checkout -B master идентиф.коммита` - переместит ветку на указанный коммит или если такой ветки нет то создаст ее и переключится

### Путешествия HEAD

HEAD это указатель, который обычно указывает на активную ветку, которая в свою очередь является ссылкой на коммит.
Можно двигать указатель отдельно от ветки.

`git branch идентиф.коммита` - сдвинет HEAD к этому коммиту.

Это состояние называется `detached HEAD`.

При новом коммите ответвление произойдет от того коммита на котором сейчас находится HEAD, но это ответвление не принадлежит ни одной ветке, что означает непригодность для разработки.

Чтобы передать такой коммит в ветку нужно

- перейти в нужную ветку и вызвать `git cherry-pick идентиф.коммита` , эта команда скопирует сироту-коммит в эту ветку

#### Восстановление предыдущих версий файлов

- Ситуация: 
Получить **версию конкретного файла , на состояние конкретного коммита,** например несколько коммитов назад 

`git checkout идентиф.коммита имя_файла` 
`git checkout 54a4 index.html`  - вытаскивает файл или папку с содежимым на момент указанного коммита. 
Такой восстановленный файл git также добавляет и в индекс.
Если в такой ситуации выполнить команду `git commit` то восставновленный файл войдет в состав коммита.
Если нам такое поведение не подходит, то можно убрать восстановленый файл из текущего индекса выполнив 
`git reset имя_файла`  - удалит из индекса указанный файл

- Ситуация:
Пишем код, затем нужно **вернуть состояние файла на момент текущего коммита**
`git checkout HEAD имя_файла` - откатит код файла на состояние начала текущего коммита.
Либо короче, НЕ УКАЗЫВАЯ КОММИТ, вернет состояние файла из индекса.
`git checkout имя_файла` - откатит код файла на состояние начала текущего коммита.